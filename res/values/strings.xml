<resources>

    <string name="app_name">まつもとひろゆきコラム</string>
    <string name="title_activity_matumoto_book_main">まつもとゆきひろコラム</string>
  <string name="closeButton_text">back</string>
  <string-array name="title_names">
	<item>コードの未来、エンジニアの未来</item>
	<item>「言語の世界」の過去・現在・未来</item>
	<item>スーパーハッカー列伝</item>
	<item>ものを作ってハッカーはゆく</item>
	<item>仕事の楽しみ方</item>
	<item>Rubyテクノロジーリーダーを訪ねて</item>
	<item>Rubyの未来　その1</item>
	<item>Rubyの未来　その2</item>
	<item>まつもとゆきひろ×茂木健一郎 「日本のエンジニア」</item>
	<item>世界のオープンソースRuby開発者</item>
	<item>自分がほしいものを作って、人をハッピーにする。</item>
	<item>茂木健一郎×まつもとゆきひろ「言語デザイナーの脳」</item>
	<item>プログラミングは人生だ</item>
	<item>ハッカーとの遭遇</item>
	<item>キーボードへのこだわり</item>
	<item>ハッカーと仕事</item>
	<item>Emacs対vi</item>
	<item>ハッカー環境問題</item>
	<item>言語の重要性その1</item>
	<item>言語の重要性その2</item>
	<item>ハッカーとオープンソース</item>
	<item>測定狂時代</item>
	<item>ソースを読もう</item>
	<item>Let\'s Talk Lisp</item>
	<item>pスケーラビリティ</item>
	<item>プロジェクトの障害</item>
	<item>Get Thing Done</item>
	<item>後輩からの手紙</item>
	<item>オープンソースのマーケティング</item>
	<item>キャズム</item>
  </string-array>

  <string-array name="sentens">
	<item>
―― 本日は貴重な機会をありがとうございます。今回、まつもとさんの最新著『コードの未来』を拝読して、それらを使いこなすエンジニアにはどんな未来が待っているのかをお聞きしたくてお伺いしました。\n
\n
なかなか難しいテーマですね……。でも、拙著を読んでくださってありがとうございます。\n
\n
―― この本では、数々の開発言語やプログラミング手法の現在・過去・未来について、私見を交えながら詳しく述べていらっしゃいますね。\n
\n
そこで伺いたいのは、まつもとさんはソフトウエア産業の現状についてどう見ていらっしゃるか、ということです。本質的な部分では変化していないのか、何かしらのパラダイムシフトが起きているのか。\n
\n
本にも書きましたが、テクノロジートレンドそのものは比較的予想しやすくて、おそらく当面はムーアの法則を軸にして進化していくと思います。来年あたりに量子コンピュータが実用化されたら、今までの流れが全部ひっくり返っちゃうかもしれませんが（笑）。まぁ、ムーアの法則を基にして考えれば、コンピュータがより安く、性能が良くなり、容量が増えるという基本ベクトルは、それほど変わらないはずです。\n
ただし、ここ何年かで、方向性が変わり始めたと感じる部分もなくはない。それは、ハードウエアの進化が、ソフトウエアに対しても変化を要求するようになっている点です。\n
\n
マルチコア＆クラウドの台頭で変わるソフトウエア開発\n
僕がRubyを作り始めたのはだいたい20年前なのですが（※編集部注：1993年から開発）、20年前のRubyを今のコンピュータで動かしても、非常に速いスピードで動くんですね。\n
ソフトウエアが「動く環境」としては、長年大きな変化はなかったと話すまつもと氏だが…\n
これが示す事実は、20年以上もの間、一つのコンピュータでソフトウエアを動かすという仕組みに、実質的な変化が起きなかったということ。\n
それが最近、CPU一個あたりの性能の伸びが頭打ちになってきたこともあって、たくさんのCPUに処理を分散させる形に移り変わってきていますよね。そうなると、今までのソフトウエアは、せっかく生まれたメリットを享受できなくなってしまいます。\n
この切り口からソフトウエアのあり方を考えてみると、そろそろ開発の仕方も変わらなければならないフェーズが来ていると感じています。\n
\n
―― それについてまとめているのが、御著の最終章にある「マルチコア時代のプログラミング」ですね。\n
\n
はい。マルチコアだけではなく、クラウド化の流れも基本的に同じだととらえています。コンピュータの中に複数のCPUがあれば「マルチコア」になり、ネットの向こう側にあると「クラウド」になる。\n
いずれにせよ、ソフトウエア開発の未来を先読むキーワードは、「たくさんあるコンピュータをいかに使いこなすか？」という点に集約されます。\n
\n
―― では、マルチコアやクラウドが前提になっていくと、ソフトウエア開発者に求められる働き方はどう変わっていくとお考えですか？\n
\n
目先の変化からお話すると、この10年くらいの間でWebベースでの開発がどんどん増えてきましたよね。Webはもともとスケールしやすく、分散させやすいアプリケーションアーキテクチャなので、これまでWeb系の開発に従事してきたプログラマーは、マルチコア・クラウド時代にうまくフィットできる素地を持っていると思います。\n
汎用機時代のアーキテクチャしか知らないようなエンジニアに比べれば、未来に適応しやすいんじゃないでしょうか。\n
\n
―― 確かに、Webサービスやスマートフォンアプリなどを開発するスタートアップ企業に取材をしていて感じるのは、この1、2年の間でPaaSやクラウドを利用してサービス開発をするエンジニアが急速に増えていることです。\n
\n
そうですね。僕も、これからは開発環境を「自社で持たないプログラミング｣が主流になっていくと見ています。そして、この「持たない」という考え方は、開発の仕事だけでなく、企業経営にも影響を及ぼす重要なキーワードになっていると思うんですよ。\n
\n
「持っている」ことが、資産ではなく負債になる時代へ\n
\n
昔のビジネスでは、「持っていること」がパワーの源泉でしたよね。高性能な汎用機を自社で持っている会社はいろんな業務を高速で処理できたけど、（高価で）持てない会社はそろばんでやるしかない、というように。\n
でも今は、「持っていないこと」の方が有利になるように変わってしまった。物理的なコンピュータを持っていると、「減価償却するまであと5年かかるから何とか活かさなきゃいけない」というように、後ろ向きの判断を生みます。すると、古いコンピュータが招く低生産によって、失うものが数多く出てきます。\n
つまり、保有するということが、資産ではなく負債になってしまう時代なんです。最新鋭のコンピュータがあれば開発をもっと効率化できる優秀なエンジニアがいるのに、3年前のものを使わされた結果、コンパイルに1時間も待たされてしまうとかね（笑）。\n
\n
Herokuのようなクラウドプラットフォームの誕生で、開発における「持てる者の優位性」はほぼゼロクリアに\n
\n
一方で、「持たない」ことがもたらすメリットは、ビジネス面、開発面共にいろんな部分に表れています。\n
例えば今、スタートアップ企業がたくさん生まれているのもその影響ですよね。一昔前なら、データセンターに投資したり、レンタルサーバ屋でマシンを10台買ったりと、起業するには一定以上の準備資金が必要だったじゃないですか。それが、今ならHerokuを採用するだけで、最初の1ノード分は無料で使えたりする。\n
そうなってくると、新しいことを始めるリスクやコストって、プログラマーが開発に掛けた時間以外はほぼゼロになります。自分のアイデアだけで勝負できるようになるし、仮に失敗しても、ほとんど負債を抱えることなく素早くやり直しができるようになる。\n
以前、アメリカのファンディング会社Y Combinatorを興したポール・グレアムのエッセイ「ラーメン代稼ぎ（原題：Ramen Profitable）」を読んだ時、「現代のスタートアップは少人数のグループがインスタントラーメンを食える程度の稼ぎがあれば新しいチャレンジができる」というくだりがあって、言い得て妙だなぁと思ったんです。「持たない」ことで可能になるフレキシビリティや迅速性が、能力のある人たちのチャレンジを後押ししているんですね。\n
そして、この流れはスタートアップにとどまらず、去年、一昨年くらいから大企業にも波及しています。\n
アメリカでは、ディズニーやベストバイなんかがRuby、Rails、Herokuを使って自社サービスを速く安く立ち上げようという取り組みを始めていますよね。これまではベンチャー企業の特権だった「新規サービス開発の速さ」や「開発の柔軟性」は、もうベンチャーだけのものではなくなっているんです。\n
\n
―― 日本の大企業や、大手開発会社の動きはどうでしょう。\n
\n
僕は大企業の”中の人”ではないので正確な分析はできませんし、各論で見れば明るい兆候も見受けられます。ただ、外から見ているだけの存在である僕の全体的な印象をお話しするなら、ちょっと「暗い未来」が待っているよなぁと。\n
\n
技術革新の「本当のメリット」を見逃している開発案件が多過ぎる\n
―― 「暗い未来」を予想する理由は？\n
\n
旧態依然のソフトウエア開発が、いまだに主流派を占めているということです。\n
Webサービスをインストールする最後のところだけAmazonのクラウドサービスを使っているけれど、開発プロセスは前となんら変わっていなかったり、プログラムを1行も書いたことのないSEが設計フェーズを仕切っていたり。一つのソフトウエア開発チームに何十人もかけたりするのも、いまだによく聞きますよね。\n
現在のソフトウエア開発は、「表面上だけ最新テクノロジーの良いところ取りをしているものも多い」と指摘\n
これらは、さっき話した「持たない強み」とは真逆の状況ですし、中途半端に流行を取り入れただけの開発案件もたくさん見聞きします。\n
「プライベートクラウド」なんて単語を聞くと、ただただ悲しくなってしまいます。だって、クラウドサービスはネットの向こう側にあるたくさんのコンピュータを使えるのが最大のメリットなのに、プライベートクラウドは自社内に数多くのコンピュータを持って”クラウド的サービス”として提供しているわけですよね。それって「持っちゃってるじゃん！」と。その時点で、もうダメというか。\n
\n
―― 最新の技術トレンドを取り入れている風ではあるけれど、本当のメリットを見逃しているケースが多いということでしょうか。ほかに、まつもとさんが「暗い未来」を暗示していると感じる部分はありますか？\n
\n
今はBtoBの大規模開発でも、スタートアップの”小さなソフトウエア”開発でも、「持たないこと」のほかに開発スピードがとても重要視されるようになっていますよね。ヤフーさんが「爆速化」という言葉を使い出していますが、速さこそが差別化、競争優位性につながるわけです。\n
その視点で考えると、いわゆるシステムインテグレーターと呼ばれる人たちの仕事は、ほとんどが時代遅れになってしまうのではと思っています。\n
「時代遅れ」になっても仕事は残り続けるのか、それとも不要な存在になってしまうのかは、わたしには分かりません。が、間違いなく言えるのは、ほかの世界で本当に実力と能力を発揮しているエンジニアとの格差が、どんどん開いていく一方だということです。\n
\n
「普通に開発をしている人」の職業的寿命は5年持つかどうか\n
―― 「実力と能力を発揮しているエンジニア」とは、どのような人ですか？\n
\n
自分が社会に提示したいソフトウエアやシステムの形を思い描けて、実際に提供までできる人たちです。Web系かSI系か、コンシューマ寄りかビジネス寄りかは関係なく。\n
\n
―― 設計から実装まですべてできるエンジニアということでしょうか。\n
\n
そうですね。そもそも論として、「設計だけ」をやるエンジニアなんて不要なんですよ。ソフトウエア開発では、「人はコード書きから離れては生きていけない」というのが僕の持論。ラピュタのセリフじゃないですけど、人は地に足を付けて生きていかなければダメなんです（笑）。\n
不自然な分業制がソフトウエア開発を「暗い未来」におとしめると話すまつもと氏\n
ソフトウエアを開発しない人が設計だけしているなんて、ナンセンス極まりない。なのに、これまでそういう仕組みで日本のSI産業が成り立ってきたのは、マージンがたくさんあったからです。\n
設計をやる人がワケの分からない仕様を出してきても、その下でコーディングする人たちが何とかごまかしてやりくりしたり、少々性能の悪いソフトウエアだとしても、文句を言いながら使ってくれるユーザーがいたり。いろんなマージンによって、粗が吸収されていたのです。\n
でも、先ほど話したように開発のスピードがどんどん速くなってくると、合わせてマージンも小さくなっていきます。以前のようなやり方では、粗をカバーし切れなくなる。\n
僕の肌感覚だと、これまでと同じ価値観で「普通にソフトウエア開発をしている人」は、あと5年、身が持つかどうかといったところではないでしょうか。\n
さらに言えば、コーダーからプログラマー、SEに昇進していくというエコシステム全体が消えてなくなる可能性すらあるわけですから、それを前提に個々人が身の振り方を考えなければなりませんよね。\n
レンタルビデオ屋さんにDVDがぽつぽつ並び始めたと思っていたら、すぐにVHSが棚からなくなっていったように、変化とは突然、一気に起きるものです。\n
自分の人生をコントロールできる人、できない人の違い\n
\n
―― では、その｢暗い未来｣に巻き込まれたくないというエンジニアにアドバイスするとしたら、どのようなアクションを勧めますか？\n
\n
何か新しいものを作ることができるようになれ、ですかね。それ以外に、差別化する方法はないと思いますよ。\n
これは「そこまで暗くない未来のシナリオ」ですが、既存のシステムがどんどんWebに置き換わろうと、あり物の組み合わせでサービスを提供していくような仕事はなくならないでしょう。今後もそこで食っていくエンジニアは、一定数はいると思うんです。\n
それでも、将来のリスクの総量で考えれば、新しい言語なり開発手法を身に付けて、新しいものづくりをしていく方が、安泰なんじゃないかと。\n
\n
―― まつもとさんのおっしゃる「新しいもの」とは、何を示すのでしょう？\n
\n
3つの階層で考えられると思います。\n
1つは、お客さまに対して新しいサービスを提供していくという選択。ビジネスモデルとして新しいものを提供する、もしくは類似サービスよりも格段に使い勝手を良くするのも、新しいものを提供することにつながりますよね。\n
新しいものを作り続ける一環として、今春には組込みシステム向け軽量Rubyの『mruby』をgithub上に公開\n
2つ目は、技術面で新しさを提供していく選択です。既存のWebアプリケーションフレームワークより性能が良いものを開発したり、これまでできなかったことができるアプリケーションを開発するなどが、この階層でできることでしょうか。僕がやり続けてきたのもここです。\n
もしくは、もっと下のレイヤーで新しいアルゴリズムを見つけるような道も考えられます。\n
それぞれのレイヤーで難しさは違いますが、いずれにしても今までなかったものを作るという点で共通しているし、こういったチャレンジを続けられる人が「変化に強いソフトウエアエンジニア」になれるんです。\n
ちなみに、この3つの道以外で仕事をしていくエンジニアは、結局は「この言語が流行っているので習得しよう」、「こういうフレームワークを使って開発しよう」などと、トレンドを追いかけることでしか生きられないわけで、それって主体性がないじゃないですか。\n
エンジニアとしての基礎体力をつける上で、流行を追ったり既存のものを学ぶのは大切ですが、それをゴールにしていると自分で人生をコントロールできないまま終わってしまう。「流行を追従する」、「あり物を学ぶ」、「組み合わせる」以外の道を選んだ方が、幸せなエンジニア人生を歩めるんじゃないかなと思います。\n
\n
―― まつもとさんご自身は最近のmrubyしかり、20年近く「新しいもの」を作り続けていらっしゃいますが、そのモチベーションはどこにあるんですか？\n
\n
僕にとってソフトウエア開発とは、「理不尽さへの反逆」である\n
―― 少々意地悪な問いですが、一般的に、自ら何かを生むよりも流行を追従してお金をもらう方が楽じゃないですか。なぜ、それでも新しいものを生み続けようと思うのか。\n
\n
うーん、何でしょうね。表向きの答えは、新しいプログラムを書いて、それが動いた時の喜びがあるからです。ただ、本音で言うと、僕は理不尽なことが嫌いだからでしょうね。\n
ほかの人は僕とは違う考え・価値観で生きていて、他人が作るソフトウエアには、僕からすると「何でこういう仕組みになってるんだ？」、「ちょっと使いづらいんだけど」と思う部分が必ずあるわけです。\n
\n
―― とはいえ、すべてのプロダクトには多かれ少なかれ「作り手のエゴ」が入ってきます。\n
\n
「理不尽なことが嫌いなだけ」と明かすまつもと氏だが、その姿勢が多くのプログラマーに愛される言語を生んだ\n
おっしゃる通りで、僕もそれを否定するつもりは毛頭ないんです。単純に、僕は他人のエゴを強要されるのがイヤなだけ。必要であれば自分で手を加えたいし、自分で改善したい。それが、ソフトウエアエンジニアを続けている理由であり、オープンソースにかかわり続ける一番の理由です。\n
オープンソースコミュニティはすべてのソースコードが公開されていますし、なぜそういう構造になっているのかもオープンじゃないですか。だから、改善したいと思えば、自分の力で変えていける。\n
社会が理不尽なのはしょうがないとして（笑）、少なくてもソフトウエアに関する部分では自分で理不尽さを直していきたいですし、自分で作ったものだったら、時代の変化に合わせて随時アジャストさせていきたい。\n
Rubyの開発に関しても、僕がもともと言語好きだからという理由もありますが、「そこだけは手を入れられたくない!!」という部分を自分でコントロールできる世界に住んでいたいし、少しでもプログラマーに理不尽なことを強いる部分を減らしていきたいから、今でも携わり続けているんです。\n
\n
ソフトウエア開発は、一人で社会を変革し得る希有な仕事だ\n
―― その原動力というかモチベーションは、もともとの性格から来るものなのか、それとも社会に出てたくさんの理不尽に遭遇してきたから後天的に身に付けられたものなのでしょうか。\n
\n
ソフトウエア開発の醍醐味を吐露するまつもと氏。取材時に着ていたポロシャツは『Ruby City MATSUE』プロジェクトのもの\n
性格的な部分が大きいとは思いますが、ソフトウエア開発が僕のようなわがままな人間を許してくれる世界だったから、調子に乗ったんじゃないでしょうか（笑）。\n
でも、真面目な話、ソフトウエアエンジニアって、たった一人の力で社会を変革し得る数少ない仕事の一つなんです。そんな幸せな職業に就いている以上、やらない手はないというのが僕の考えです。\n
\n
―― こういった未来予測の話だと、人によっては～すべきという「べき論」を語ることも多いのですが、まつもとさんは一貫して「幸せか不幸せか」という価値観でお話されますね。\n
\n
まぁ、何人も、他人の人生の責任は取れないじゃないですか。例えば「matzがこうしろといっていたのに、やってみたらダメだった」とか言われても、僕は責任を取れないわけで。だから、自分の生き方は自分で決めるしかないと考えているんですね。\n
でも、「今後の展望がこういう風になるかもしれない」、「僕はこうやってきたから君もハッピーになれるんじゃない？」と話すことなら、僕にもできる。だから「べき論」にはならないのだと思います。\n
今ここで話していることについても、「まつもとの言うことには同意できない」と思ったエンジニアは、ご自身の信じた道を生きる方が幸せなんですよ。\n
\n
―― その考え方にはとても共感します。では最後に、そうやって「未来」を作っていく上で、なぜまつもとさんは「過去」から多くを学ぼうとされたのかを教えてください。\n
\n
なぜ僕が過去から学ぶか、ですか？\n
\n
未来を探る上で最も重要なのは「人間は変わらない」という事実\n
\n
―― 『コードの未来』を読んで印象的だったのが、まつもとさんは各言語の発祥やトレンドの変遷を、とても詳細に調べていらっしゃるなぁと。ただ、ITの世界では時に、過去の成功法則がまったく通用しなくなるような破壊的な変化が起きますよね。\n
\n
マルチコアやクラウドの流れも、そのような破壊的な変化の兆しなのであれば、なぜ過去の潮流を調べ、書籍にまとめる必要があったのかと。\n
テクノロジートレンドは「振り子」のように動きながら進化していくと私見を語るまつもと氏\n
これも、人によっていろんな考え方があるという前提でお話しすると、一つ目の理由はIT業界の技術トレンドは常に振り子のように動いてきたからです。\n
新しい開発言語や手法、フレームワークがどんどん生まれてくる中で、ソフトウエア開発にかかわるそれぞれの技術は、シーソーゲームのようにバランスを取りながら進化していきます。\n
ですから、「かつてのベストバランス」がどう変遷して「現在のベストバランス」になっているのか？ という振り子の周期や、過去の技術的選択がどんなトレードオフによって生まれたのかを頭の中に入れておくと、「未来のベストバランス」もある程度推察することができるようになります。\n
例えば「分散と集合」というテーマを取り上げると、昔は大型汎用機が中央に一つあって、もっと処理能力を高めるためにとクライアントサーバシステムが台頭してきたじゃないですか。それが今、クラウドという”巨大なコンピュータ”に集約されていく流れに再び戻っている。\n
これも、ネットワークの速度とコンピュータ1台あたりの性能とのトレードオフで、振り子が動いたからです。「過去」のある一点だけを取り上げて学ぶのはあまり意味がないかもしれませんが、ある技術が過去に流行り、廃れていったのは「こういうトレードオフがあったから」という流れを知るのは、未来に対して仮説を立てる上でとても参考になります。\n
そして、過去を学ぶことの最も重要な要素は、「人間は変わらない」という事実です。\n
技術的な変化の振り子を測るパラメータとして、人間の能力の限界によって制限される部分は多々あるんですね。だから、さまざまな言語開発者が、過去に「人間」というものをどう見ていたのかを知るのは、改善や進化のきっかけになります。\n
本の中でも、DartやGoのような新しい言語について触れていますが、Rubyの開発者である僕が「言語開発者の目線で言語開発者の心理を慮る」のは、単純に面白かったし人間に対する理解を深めることができました。\n
\n
―― 新しいものを創るためになぜ温故知新が大切なのか？ というのが質問の意図だったのですが、人間を慮る力というか、開発者の心理のような部分を過去から学ぶというのが、一番大事なのかもしれませんね。\n
\n
最初にも話しましたが、コンピュータって世の中で言われているほど変化していないんですよ。\n
50年前に作られたプログラミング言語がいまだに使われていますし、Rubyだって、「最近話題になっている」とかよく言われますが20年も前からあったものです。人が思っているほど、状況は変わっていないという証拠ですよね。\n
そう考えると、新しさばかりに目を奪われてないがしろにしてきた過去の事実ってけっこうあるなぁと。ソフトウエア開発者も、ただトレンドを右から左に受け流しながら生きている人より、トレンドが移り変わる原理原則を覚えようとする人の方が、きっとエンジニアとして”長生き”するんだと思います。\n
そうなりたいと思う方は、ぜひ『コードの未来』を読んでね、という宣伝も兼ねて（笑）。\n
\n
―― 今日はとても本質的なお話をありがとうございました。\n
    </item>
	<item>
FORTRAN vs. LISPではじまった言語の歴史\n
\n
　そもそもプログラミング言語とは何なのか。セッションの冒頭、まつもと氏はこの本質的な問いに対し、以下2つの異なる定義を示した。\n
その1 :プログラム＝手順書・手順書記述用人工言語\n
その2  :プログラム＝理想記述・思考表現用人工言語\n
　その1を"機械のため"とするなら、その2は"人間のため"の定義となる。機械が理解できるように手順を記述するのか、それとも達成したい理想を人間にわかる言葉で記述するのか。まつもと氏は「機械のためか人間のためか、せめぎあう2つの立場が交錯してきたのがプログラミング言語の歴史」とする。\n
満席の「デブサミ2012」会場で講演する、まつもと ゆきひろ氏\n
　その立場の違いが際立つのが、プログラミング言語が登場したばかりの1950年代に見られる"FORTRAN vs. LISP"という構図だ。いずれも機械と人間という2つの立場をそれぞれのやり方で取り入れた言語である。\n
　1954年に誕生した世界初の高級言語、人間にわかる言葉＝数式でプログラムできるように開発されたFORTRAN(FORmula TRANSlator)は、ループアンローリングやベクトル化を取り入れ、"速く計算する"ということにこだわった。その時代背景にはコンピュータが非常に遅かったという事情がある。しかし、当時、言語の常識がまだ存在しなかったこともあり、「スペースを全部落とすなど、"人間のため"という点では未熟な部分が多かった」(まつもと氏)という。\n
　一方、1958年に誕生したLISP(LISt Processor)は"人間のため"がFORTRANより向上している。ラムダ計算を理論的基盤とした数学的概念からスタートしたLISPは、IBM 704計算機上で実装されたため、そのレジスタを構成するcar(content of adress part of register)とcdr(content of decrement part of register)が、LISPの基本的関数の名前として現在も使われている。また、Javaでおなじみのガベージコレクタを生み出したのもLISPである。\n
　さて、FORTRAN vs. LISPという戦いはどちらが勝ったのか。まつもと氏は「勝者は結果として漁夫の利を取ったAlgol(Algorithmic Language)だった」とする。原始的すぎるFORTRANと数学的すぎるLISP、いずれも現在に至るまで使われている言語ではあるが、主流となることはなかった。Algolは現在ではほとんど利用されていないものの、アルゴリズム記述をベースとした構造化プログラミングのスタイルは、PL/I、Pascal、Ada、Eifel、C、C++、Java……と数多くの"Algol属"を生み出し、現在に至っている。もちろんRubyもAlgol属だ。\n
\n
人はなぜ新しい言語を求めるのか？\n
\n
　FORTRAN vs. LISPからやや時を経た1960年代後半から1970年代前半、まつもと氏はこの期間を「言語のカンブリア爆発」と呼ぶ。システムプログラミング言語のC(1972年)、オブジェクト指向言語のSimula(1967年)、スクリプト言語のShell(1971年)、関数型言語のML(1972年)など、現在の主要な言語の基礎はほぼこの時期に出揃ったといっても過言ではない。「言うなれば、現在は言語設計者にとっては受難の時代。新しい言語を考案しても"どうせ既存の言語の組み合わせでしょ"と言われてしまう」(まつもと氏)。\n
　ではなぜ、人は新しい言語を求めるのか。60年代、70年代の思想で十分に表現できるのなら、新しい言語は必要ないはずだ。にもかかわらず、現在人気のある言語は最近になって登場したものがほとんどである。例えば、Perl(1986年)、Python(1990年)、Ruby(1995年)、PHP(1995年)、Java(1995年)、C#(2000年)、Scala(2003年)、Erlang(1986年)、……最近か？と疑問をもたれる向きもあるかもしれないが、「言語の世界で10年、20年ははなたれ小僧のレベル」とまつもと氏。\n
　まつもと氏は、言語設計者が新しい言語をつくる動機として、「10万人にひとりくらいの割合で、言語のデザインそのものに惹きつけられる人間が現れる。そういう人間が"言語を作りたい"という気持ちを持つようになる」と語る。その気持ちが生じたときに、\n
・新しいパラダイム ：構造化プログラミング、オブジェクト指向プログラミング、関数型プログラミングなど(ただしここ20年くらい新しいパラダイムは生まれていない)\n
・新しい環境 ：新しいOS、新しいCPU、新しいアプリケーションなど\n
・新しい制約 ：CPU数、メモリ量、データ量、アクセス量など\n
　といったITの世界の変化のタイミングがうまく合うことで、新たな言語が誕生するという。「例えば、Webという新しいアプリケーションが登場したことでPHPが生まれた。時代を取り巻く環境が変わることで、求められる言語も変わる」(まつもと氏)。 もっとも"言語"とはそもそも、どこからどこまでを指しているのだろうか。まつもと氏は、\n
・文法、ライブラリ、アーキテクチャ\n
・デザインパターン、コミュニティ、エコシステム\n
・思想、人格\n
　までを含むとする。言語の仕様には、設計者の哲学が込められている。逆に言えば、哲学を感じられない言語は言語ではないということなのだろう。\n
\n
未来に求められる言語の姿\n
\n
　ITの世界ではときどき、1年後、5年後、10年後といった近い将来を占うことが行われる。そんなときは、これまでの歴史を振り返ってみると、意外と見えてくるものが多い。いわゆる"温故知新"である。まつもと氏はコンピュータの世界においては、歴史の振り子は常に、\n
・集中vs.分散\n
・性能vs.生産性\n
・静的vs.動的\n
・正確さvs.柔軟さ\n
　のどちらかの側に振れているという。「昔は組織には、大きなホストコンピュータが1台しかなかった。人々はそのまわりに電話回線を巡らせて、周囲に端末を置いた(集中)。でも1台のマシンの性能には限界がある。だからホストコンピュータの性能を上げることよりもその価格を下げるほうにトレンドが傾いた。すると台数が増えて今度は分散するようになり、そのうちにWebが登場した。言うなればブラウザは、昔のホストコンピュータのまわりにあった端末のようなもの。Amazonのクラウドなんてまさに"集中の中の分散"を象徴している」(まつもと氏)。\n
"Enjoy Programming"生みの親が心の底から楽しみながら作った言語、それがRubyだ\n
　言語の世界も同様だ。コンピュータの性能を上げるのではなく、言語で生産性を高めていこうとしたからこそJavaやRubyが生まれた。歴史の振り子が次に振れていく先を見つめれば、未来にあるべき言語の姿は自然と現れてくる。\n
　まつもと氏は「新しいぶどう酒は新しい皮袋に、古いぶどう酒は古い皮袋に」という聖書の言葉を引用し、新しい時代はやはり新しい言語が必要になると説く。「大規模分散と高抽象度、これが新しい言語のポイントになる。マルチコアやクラウド、ビッグデータ、ソーシャルゲームといったトレンドが進めば、近い将来必要とされるのはErlang、Node.js、R、SQLの発展形なのでは」(まつもと氏)。\n
・Erlang :分散とアクターモデル。既存の言語にアクターモデルが付いてカバーされるかも？\n
・Node.js :大量アクセスと非同期モデル。非同期I/Oによって多重化する発展形が流行るかも？\n
・R :統計/解析とビッグデータ連携(R-ODM)。非常にニーズが高まっている\n
・SQL :宣言的データ取得と高抽象度、そしてHive。本質は宣言的データ取得。SELECT文など、具体的にどうすべきとかあまり考えなくていいところがすばらしい\n
\n
機械の中に自分の宇宙を作る、それがプログラミングの魅力\n
\n
　みずからを"言語オタク"と称するまつもと氏は、講演の終盤、"言語の楽しさ"についてこう語った。 「僕にとって言語の楽しさとプログラミングの楽しさは同義。言語を通さないとプログラミングはできない。はじめて買ったポケットコンピュータ、それも行編集しかできないような代物だったけど、自分が思ったとおりにコンピュータが動くという楽しさを実感した。まるで犬にお手をさせるような感覚に近い。機械の中に自分の宇宙をつくる―それがプログラミングの最大の魅力」。\n
　「処理系を作るのはすごく楽しい。言語実装はプログラミングの総合芸術だと思う」。 「言語設計とは、発想をプログラミングすること。つまりRubyプログラマは、Rubyの発想に染まっているといえる。ということは、Rubyプログラマは僕の発想でプログラムされているんですよ(笑)」。\n
　会場を埋め尽くした300人を超える聴衆に、広くて深い言語の世界を垣間見せてくれたまつもと氏。最後は「新しい言語を作ったり、既存の言語を伸ばしたり、言語を使ってプログラミングしたり…、とにかく楽しんでプログラミングしましょう」と"Enjoy Programming"のメッセージを残してくれた。生みの親が心の底から楽しみながら作った言語、それがRubyだ。世界中で愛される理由のひとつがそこにある。\n
	</item>
	<item>
＜コンピュータとの出会い＞\n
\n
川井　本日はよろしくお願いします\n
Matz　よろしくお願いします\n
\n
川井　まずは子供の頃のお話をお聞きしたいのですが、幼少の頃にコンピュータに触れるきっかけとかってありましたでしょうか？\n
\n
Matz　1970年代の終わりくらいにTK-80とかマイコンブームというのがあったんですよ。ワンボードマイコンですね。この頃は完成品じゃなくて，キットなんですよ。私の父親は全然コンピュータと関係ない仕事をしていたんですが、元来そういった技術系のものに興味がある人で、日本橋の電器屋に行って10万くらいするパナファコムのL-Kit16とかを買い込んで、家に持って帰ってきてはんだごてを使って組み立てて、「動いた」って喜ぶわけです。当時のコンピュータって動いただけだと何もできないんですが、父は動かすことで満足してしまったので、その後放置されていたのをまだ小さい私が電源を入れていじっていたんです。付録の冊子にプログラムの16進DUMPがついていたので、それを打ち込んで7セグメントLEDがぐるぐる回るのを見て「動いた、動いた」っていう風に言っていたのが、コンピュータとの最初の遭遇ですね。\n
\n
川井　それはいくつくらいの時ですか？\n
\n
Matz　小学校6年生くらいの時ですかね。\n
\n
川井　もともと自分で興味をもってコンピュータの世界に首を突っ込んだというよりは、環境の影響の方が大きかった感じですか？\n
\n
Matz　環境もあったと思いますが、もともと理系の分野に興味があったんだと思います。例えば当時からSFが好きだったり、父が買って来た物理の本を読んだり、知識欲は旺盛で理系や技術の世界に関心のある子供だったとは思います。そんな子供だったので、自然と目の前にあるコンピュータで遊んだって感じだと思います。ただ、当時はプログラミングまでは行かなくて、何本かプログラムを打ち込んでLEDをぐるぐる回したり、サイコロを乱数で表示させたりまでで終わってしまってその後は続かなかったんですよ。やっぱりハンドアセンブルは当時の小学校6年生にはきつくてですね（笑）、インストラクション表とかもあったとは思うんですけど、プログラミングまでは届かなかったですね。\n
\n
川井　数学が苦手って言ってたと思うのですが、理系に興味があるということは数学も好きという気がするんですが。\n
\n
Matz　理系っぽい事への興味と成績は全然関係ないということで（笑）、高校は進学校っぽいところへ行ってて、理系だったんですけど，得意科目は国語、英語、社会で、数学や物理などの成績は悪かったんですよ。\n
\n
川井　それは面白いですね。\n
\n
Matz　計算が入るとモチベーションが維持出来なくて、とたんに駄目なんです。電卓叩けばいいじゃんて思っちゃったり。あとは定理に関心がなくて覚えられないといった具合でした。多分、机の上に電卓があって、目の前に定理が書いてある紙が貼ってあったら、試験もそこそこ出来たかも知れないんですけど、そんな試験は高校生の頃にあるはずもなく(笑)、本当に成績が悪かったですね。\n
\n
川井　そうなんですね(笑)\n
\n
Matz　本当に、出来なかったんです。\n
\n
川井　ある意味、機械がやってくれる部分は人間がやらなくてもいいという考え方があったのかも知れませんね。\n
\n
Matz　そうかも知れませんね。まったくやる気にならなかったですね。だから、計算が入る物理、化学は全然駄目でしたし、数学も定理を思い出さないから、試験中に定理を作ったりするわけですよ。「こういう関係にあるからこういう定理があるに違いない」とかやってたら時間が足りるわけないですよね(笑)。もう全然駄目でしたね。\n
\n
川井　それは面白いエピソードですね(笑)。\n
\n
Matz　それは高校の頃の話なんですけどね。ちょっとさかのぼりますが、プログラミングとの最初の接触はやっぱり父親の影響が大きくてですね、中学校3年生の時にSHARPのPC-1210というポケットコンピューターを父親が買って来たのですが、それは400ステップしかないんですよ。ステップというと大体BASICで１行相当ですね。なので最大400行しか書けない関数電卓って感じでした。そのポケコンにプチプチとプログラミングを書いていました。後にメモリ増設して1400ステップまでは書けるようにしましたけど(笑)\n
\n
川井　3倍以上ですね(笑)\n
\n
Matz　それを機にプログラミングというものに接して、しばらくBASICでプログラムを書いてたんですが、リアルタイム入力はできないし、グラフィックは出来ないし、何もできないんです。でも、マニュアルにサンプルプログラムとかが載っているので、それを打ち込んで改造してみたり、それをアレンジしてみたりしてました。\n
\n
川井　なるほど。\n
\n
Matz　今でも覚えているものがあるんですけど、Lunar Landerって知ってます？\n
\n
川井　いえ、ちょっと分からないです。\n
\n
Matz　もともとはBASICで書いた月面着陸のリアルタイムゲームですけど、どんなゲームかと言いますと、月に着陸するのに、燃料を噴射してだんだん減速して行って、丁度月面に到達するときに速度０で接すると着陸成功、逆に速すぎたり遅すぎたりすると着陸失敗というものなんです。でも、私の持っていたポケコンは当然のようにリアルタイム入力がないので、そんなことできないわけですよ。で、どうするかっていうと、画面上に今高さがどのくらいで、速度がどのくらいとかっていうのが出るんですが、それで燃料をどれくらい投入するかって入れてエンターとかってやると、数秒後の高さや速度、燃料などが表示されるんです。それを見て「今度は高さがいくつになって、速度がいくつになった、うーん」とかいいながら入力してやると段々進んでいくんですけど、ちょうど高さが０の時に速度が０だと着陸成功、速すぎると失敗、燃料がなくなっても落ちちゃうので失敗てな感じなわけです。\n
\n
川井　プログラミングというより計算でやるゲームですね\n
\n
Matz　そうです。計算だけのゲームなんですけど、そんなことをやってて、プログラミングに入ったのが最初ですね。\n
\n
川井　ゲームが１つのきっかけだったんですかね？\n
\n
Matz　最初の１歩はゲームだったかもしれないですね。でも、その後はほとんどゲームはしてないですね。\n
\n
川井　エンジニアの方はゲームから入られる方が多いですよね。\n
\n
Matz　多いですね。普通はそのままゲームに行くと思うんですが、私は高校くらいからはほとんどゲームとかはやっていなくて、私とか私たちのちょっと下の世代だとベーマガ(マイコンBASICマガジン)という雑誌があって、そういう雑誌にプログラムのリストが載るんで、それを一生懸命コンピュータに打ち込んでゲームするというのがよくあったんですけど、私の場合はそういうゲームはあんまりやらなくて、コンピュータの本を読むことの方が楽しいかなと思っていました。「いつか、ちゃんとしたというかまともなコンピュータが手に入ったら、やりたいことがある」とかって言って本を読んでるという感じでしたね。\n
\n
川井　本はかなり買い込んでいたのですか？\n
\n
Matz　ASCIIとかの雑誌は買っていましたけど、あとはほとんど立ち読みでした。コンパイラや人工知能の本やなんかも読んでたんですが、5,000円や7,000円くらいするので高校生じゃなかなか買えないですよね。難しい本を仕入れた上に立ち読みを許してくれた本屋さんには感謝してます。\n
\n
川井　当時から、既に仕事としてプログラミングをやっていくとか、生涯これをやっていくんだという気持ちは片隅にでもあったんですか？\n
\n
Matz　高校を卒業して、情報系の学校に進学しようと思った時には、ぼんやりとですが、これでずっとやっていこうとは思っていました。ただ、父親は反対していて、機械系エンジニアとか、そっちの方面に行って欲しかったみたいで、コンピュータは趣味にしておけとか言われたりしましたね。まだ1980年代の前半で、コンピュータがまだちゃんとした職業になっていくかどうかなんて分からない時代だったので、そうは言われましたけど、コンピュータのことをちゃんと勉強したかったので、親の言うことを聞かずに情報系に入学しました。\n
\n
＜紙での言語デザイン＞\n
\n
川井　以前、横浜で講演を聞いたときに、紙でプログラミングをしていたと聞いた記憶があるのですが、それは一体何だったのでしょうか？\n
\n
Matz　それは、紙でプログラミングというより言語デザインをしていたんですね。高校の頃には，BASICはちょっと駄目だろうって思っていて、世の中にもう少しマシな言語はないだろうか思っていろいろ探していたんですよ。で、見つけた本がPascalの本だったんですね。それはお小遣いをはたいて買って（笑）、結構時間がかかりましたけど、最初から最後まで読み通したんですよ。もちろん、手元にPascalが動くコンピュータはないので、実際に実行できないんですが、「私はPascalをマスターした」とか、なんだか分かった気になっていました。まあ、実際にマスターしたかどうかはともかく、「Pascalっていうのは、私の今まで知っていたBASICよりもずっといい言語だ。世の中にはBASICよりもいい言語が存在するんだ」って思ったんです。で、その後，だんだん知識が増してくるとBASICとPascal以外にも世の中にはたくさん言語が存在することが分かってきて。で、その言語ひとつひとつが誰かが作ったから存在するわけですよね。でも、BASICには満足できなかったし、PascalもBASICよりはずっとよかったけど、完璧だとは思わなかった。「だったら私が作ってもいいんじゃないかな」って思ってですね、それで、ノートを引っ張り出してきて、ノートに「こんな風に書ける言語があったらいいな」といった具合に書きだしていったわけですね。まだ見ぬ言語でプログラムを書いて、「こんなだったらいいかな」っていうようなことを書いていたのが高校2年か3年ぐらいのことですね。\n
\n
川井　高校生の時にベーシックもBASICもPascalも完全じゃないないって思って、自分で言語を作ろうという発想をしたってことなんですね。すごいですよね。\n
Matz　はい。ただ、普通の高校生がプロになろうと思っているわけでもないけど漫画を描いたりするじゃないですか。あれとあまり変わらないですよね。何も実体は伴わない感じです（笑）\n
\n
川井　そういうのは、周りの人たちからはどんな風に見られていたんですか？\n
\n
Matz　コンピュータやっているという時点で、すでに異常だったんですよね(笑)　学校では、コンピュータの話をしても関心を示し分かってくれる人は居なかったので、殆んどその話はしませんでした。漫画やアニメの話をする友達は多かったので、普段はそんな話をしたりしていました。あとは、変なクラブに入っていたので、その仲間と遊んだりしていましたね。\n
\n
川井　ちなみに、その変なクラブって言うのは？\n
\n
Matz　超科学研究同好会というクラブに入っていました(笑)\n
\n
川井　それはまたどんなクラブなんですか(笑)？\n
\n
Matz　一応、もともとの主旨は超能力やUFOを研究するというテーマだったんですけど、なんでもやってましたね。とにかく遊んでる部でしたね。\n
\n
川井　コンピュータやプログラミングの他にも、結構色々なことをやられていたわけですよね。\n
\n
Matz　そうですね。自分でプログラミングをするのはおかしい人で、世の中にはそういう人はいっぱいいるけど、私の周りにはいないよねっていうそんな感じの高校生でしたね。\n
\n
川井　なるほど。\n
\n
Matz　それで、大学に行ったら、一応、情報系の学部なんで、多くの人はコンピュータをやりたいから入学したという人で、例えば自宅にコンピュータがあって、ゲームを作りましたって人もいっぱいいて、「そういう人たちはやっぱりいたのね」って思ったんだけど、どうも話をしてると、プログラミング言語を作ろうって人はやっぱりいなくて（笑）、やっぱり少数派だったのね。知らんかった（笑）みたいな感じでした。\n
\n
川井　皆んなが言語を作ろうと思っているに違いないと思ってたんですね。\n
\n
Matz　まあ、全員ではないにしても、情報系の学部なら3人に1人ぐらいはいるかなって思ってたんですけどね。全員に聞いて回ったわけじゃないですけど、私と同じ学年に80人いましたけど、見た感じ、プログラミング言語を作ろうと思っている人はいなそうでしたね(笑)\n
\n
川井　独自性は随分前から発揮していたんですね(笑)\n
\n
Matz　まあ、変だったんですよね（笑）\n
\n
川井　大学では、プログラミングの勉強に没頭した感じですか？\n
\n
Matz　没頭したというわけではないですけどね。ちゃんとしたプログラミングをできる環境が手に入ったのは大学に入ってからなんです。今までは、よその世界でプログラミングしている人の記事を読んで、憧れていただけなんですが、大学に入って実際にプログラミングがちゃんとできるようになったというのはありましたね。筑波大学は１年からプログラミングの授業があるので、ずっとプログラミングをしてました。相変わらず数学の成績は悪かったんですけど、プログラミング関係の授業だけは成績がやけにいいといった感じでした。\n
\n
川井　トップエンジニアの方々にお話をお聞きすると、小さい頃からプログラミングを経験してきた事がある人達は、大学に行っても知っている事ばかりで退屈だったという方もいれば、逆に体系的にプログラミングを勉強する機会は初めてだったので面白かったという方とで、二分するのですが、どちらかというと後者の方ですか？\n
\n
Matz　そうですね。色々な授業があったのですが、例えばアルゴリズムとかちゃんと勉強する機会ってなかなかなかったので、そういう勉強が出来たのは貴重だったと思います。あとは、今までは家の貧弱なコンピュータを使っていて、そんなにちゃんとした環境ではなかったんですが、大学には小さいのから大きいのまで色々なコンピュータが用意されていたので、4年間そういったコンピュータでプログラミングが出来た事は、ありがたかったですね。\n
\n
川井　大学に入ってから、プログラミング言語を作るっていうことについては何か進展があったんですか？\n
\n
Matz　大学3年くらいまでは、プログラミング言語を作ることって結構大変だし簡単なことではないので、自分には無理かもなって思ったんです。4年生の頃の研究室配属で、通称「言語研」と私たちは呼んでいたプログラミング言語について研究する研究室に配属されてから、「もしかして、やっぱり自分にも作れるんじゃないか」と思い始めて、言語設計に取り掛かりました。だから、大学3年までは、そこまで本気ではなかったんです。\n
\n
川井　じゃあ、大学4年になって本格的に着手したということですか？\n
\n
Matz　本格的に着手というほどではないんですが、まあ、卒論のテーマなんかは「プログラミング言語を作る」というテーマでしたね。でも、もともと「言語研」とはいっても、プログラミング言語をデザインするという研究室ではないんです。日本中探しても、そんなことをしている研究室はないと思いますしね。実際に「言語研」でやっていた研究は、「いかに最適化を行うか」とか「どういう風にプログラミング言語処理系の開発ツールを作るか」といった内容でした。だから、私が「言語デザインしたいです」と言っていたのは、研究室からしてみれば全然関係ない話で、無茶苦茶だったと思います。担当教官の先生はよく認めて下さいました。\n
\n
川井　言語を作るにあたって、色々な言語を見たと思うんですが、大体どのくらいの言語を研究されてきたんですか？\n
\n
Matz　大学の3、4年のときは、結構、図書館に入り浸ってプログラミング言語の本や古い雑誌を見つけては、「いっぱいあるんだなあ！」と思いながら、とにかく読んでいました。\n
\n
川井　世の中の主たる言語については全部見たという感じですか？\n
\n
Matz　見たは見ましたね。ただ、実際に使ってはいないので経験に裏打ちはされないんですけどね。\n
\n
川井　その中で、自分の理想とする言語はどんなものかという具合に決めていった感じですか？\n
\n
Matz　そうですね。\n
\n
川井　代表的な言語で、この言語のこんなところがいいとか、逆に良くないとかってありましたか？\n
\n
Matz　大学4年の時点での話をしますと、Eiffelという言語があるのですが、それを作ったBertrand Meyerが「Object-oriented Software Construction(オブジェクト指向ソフトウェア構築法)」(邦訳「オブジェクト指向入門」アスキー刊)というタイトルの本を出していて、当時、その本の原書を買ってきて一生懸命読んだんですが、その影響はかなり大きかったですね。このEiffelというプログラミング言語は、Adaという言語に対してオブジェクト指向の拡張をもっとちゃんとするとどうなるかっていうアプローチでデザインが始まっているんですよ。私はCプログラマだったので、卒論のテーマは、AdaがEiffelになったベクトルをCに対して加えると何が出来るかというアプローチで言語デザインするというものでした。まあ、経験は足りないし、時間はないしで、まったく実用にはならなかったですね。この時デザインした言語は、コンパイル型で静的な型があって、多重形状でといった感じで今のRubyとは全然違っているんです(笑)。\n
\n
川井　確かに全く違いますね。\n
\n
Matz　まあ、そっちもやってみて、今はRubyに落ち着いたというのもあるんですよね。\n
\n
川井　ちなみにRubyを作る前には、いくつくらいトライしたことがあるんですか？\n
\n
Matz　実際に動くところまで持っていったのは、Rubyの前はその卒論の時に作った言語だけですね。途中でやめちゃったとか、文法を考えただけとか、名前を決めただけとか、そういうのも数えると結構な数になるんですけど、普通、そういうのって書いたとは言わないんですからね（笑）\n
\n
川井　本当に趣味というか、生涯やり続けそうな感じなんですね。\n
\n
Matz　本当にそうですね。ここまで来るとは思いませんでした。\n
\n
＜宣教師時代の経験＞\n
\n
川井　ちなみに、大学の休学中のお話をお聞きしてもいいでしょうか？\n
\n
Matz　はい、大学2年が終わった時点で休学して，2年間、キリスト教の宣教師をしてました。中国四国地方が私の担当のエリアで、その間はずっと布教活動をしていました。大体アメリカ人と二人組で、自転車に乗ってあちこち回っては、教会の説明や奉仕活動をしていましたね。\n
\n
川井　何かきっかけがあったんですか？\n
\n
Matz　私、子供の頃からクリスチャンなんですよ。\n
\n
川井　それはご家庭がとかなんですか？\n
\n
Matz　はい、家族全部がです。\n
\n
川井　その信仰がRubyを創ることに結びついているといった内容の記事を見たことがあるんですが、それはどんな理由があるのでしょうか？\n
\n
Matz　それは、周りが言っているだけじゃないですか（笑）本当に子供の頃から教会に行ってて、宗教は私の一部なので、宗教があるからRubyを作ったっていうのはあまりないんじゃないかなって思いますね。私の所属してる教会のメンバーは世界中に何千万人もいて、その中でプログラミング言語を作ったのは私くらいでしょうから、論理的に考えると宗教と言語設計の関係はどうなのよって思うんですけどね（笑）\n
\n
川井　論理的に考えるとそうですね(笑)。\n
\n
Matz　ただ、2年間の宣教師活動の経験があるので、相棒にアメリカ人がいたり、ボスがアメリカ人で、日常的に英語に触れる機会も多くて、普通の日本人が中学から大学までただ授業で英語を勉強してきたっていうよりはもっと英語に対する経験を持っているとは言えると思います。Rubyが海外に出て行くときに、英語でコミュニケーションしないといけないわけですけど、その時に英語を喋れって言われたらなんとか喋れるとか、あるいは英語でドキュメントを書こうとそもそも思うとか、そういうところってそういう経験がきっかけになっているとは思いますね。それから、宣教師活動中は、すごいたくさんの人に会うので、中にはいいひとも悪い人もいるんですけど、その中で「人間はそれぞれ違う」とか「黙っていても伝わらない」っていうのを学んだっていうこととかは、役に立ってるかもしれませんね。オープンソースプロジェクトっていうのはコミュニティによって支えられている部分がたくさんあるので、コミュニティを運営しないといけないわけですよね。コミュニティを運営しているといろいろな人がいて、中には扱いにくいひともいるわけですけど、喧嘩とかするとすぐにバラバラになっちゃうんで、そういう人たちに対しても適切に接するという部分では実利的に役に立ったことはあったんじゃないかなとは思いますね。\n
\n
川井　Rubyのコミュニティの雰囲気って、まつもとさんの人柄そのものっていう感じがしていて、素人の人にもオープンな雰囲気があると思います。\n
\n
Matz　ありがとうございます。本人はあまり自覚がないんですけどね(笑)\n
\n
＜就職、そしてRuby＞\n
\n
川井　大学を出て就職する際に、どんな基準で会社を選ぶとかってあったのでしょうか？\n
\n
Matz　先生からは大学院にいかないかって言われていたんですけど、私は6人兄弟の一番上だったこともあり、いつまでも親のすねを齧っているのもどうだろうと思っていて、かといってバイトだけで学業をやりとおせる自信もなかったんで、「まあ、就職するか」って思って、普通に就職活動しました。幸い当時はまだバブルが終わっていない時代だったので、リクルートからこんな分厚い本が届いたり、今よりは楽だったと思うんですけど。基準の一つは「面白そうな仕事が出来そうなこと」でしたね。プログラミングの仕事ってピンキリだと思うんですが、言われるがまま歯車のように働くのは嫌だなと思ってましたね。もうちょっと創造的な仕事ができそうなところがいいなあと。あと、もう一つ、東京は嫌だったんです。\n
\n
川井　やっぱり昔からそうなんですね（笑）\n
\n
Matz　私の原点は変わらないですね（笑）だから、東京じゃないところで働けて条件に合った会社っていうのが最初に入った会社で、本社は東京なんですが、静岡県の浜松にある研究所で働ける会社でした。そこで4年ぐらい働きましたね。\n
\n
川井　東京に出てくるとどうしても大手に入ってしまったりしそうですが、反対に東京以外っていうようにセグメントしたのが、やりたい仕事ができる環境の選択肢はより多かったのかなと思いますが、どうなんでしょうか？\n
\n
Matz　どうなんですかね。私は割といいところに配属されたと思うので、それはよかったと思います。バブル期だったのもあって、私の同期は300人近くいたんですよね。もともと1,000人くらいのSIerだったので、300人入るってことは1年で4分の1増えるわけですよ。その300人近くの新人の中で、大学でコンピュータサイエンスをやったっていう人は6人しかいなかったんです。残りの人たちは理系でもコンピュータ経験ないし、文系はそれ以上にいっぱいいるという状態で、それでその6名は貴重なコンピュータサイエンス経験者ということで優遇されて、割りと面白そうな仕事に回してもらえました。たとえば、大企業に入社してコンピュータサイエンスをやりましたって人たちばっかり100人いるところですと、満足するポジションを得るためには100人の中で競争して勝たないといけないんでしょうけど、幸い私のところはわずか6人しかいなかったので重宝してもらえてありがたかったというのはありますね。\n
\n
川井　当時はどんな環境でやられていたんですか？\n
\n
Matz　プラットフォームがSONYのNEWSというUNIXを積んだワークステーションでした。当時はBSD系だったんですけど、その上でCで作っていました。\n
\n
川井　当時というと1990年前後ぐらいですか？\n
\n
Matz　入社が1990年でした。入社して2年目にバブルが崩壊してボーナスが無くなりました(笑)　入社した当時は景気がよくてボーナスが結構たくさん出ていたんですけどね。私は入社2年目に結婚したんですが、その途端にボーナスがなくなって、出費が増えるのに収入は減るってのはどういうことって思いましたね（笑）　その事があってから、まつもと家では「家計にボーナスを組み入れるな」という家訓ができました。\n
\n
川井　ボーナスが当たり前の設計だと厳しいときがありますよね。\n
\n
Matz　で、仕事の方も，景気が悪く予算がないので新規開発はしてはいけないということになったんです。でもすでに全国の拠点に私たちのツールのユーザーがいるんで、サポートはしなくちゃいけないっていうことで、開発はしないで、サポートだけしててくださいということになって、仕事量が激減したんですよ（笑）\n
\n
川井　（笑）\n
\n
Matz　クビにならなくてよかったですね（笑）　アメリカだったら真っ先にクビになりそうですけど。幸い日本だったのでクビにはならなくてフラフラとしてて、暇なんで時間もあるしコンピュータもあるし、好きなプログラムでもするかなってことで始めたのがRubyなんです。\n
\n
川井　なるほど。\n
\n
Matz　不景気が生んだ言語ですね（笑）\n
\n
川井　なるほど、面白いですね（笑）するとその時は仕事中にやっていたんですよね？\n
Matz　はい、仕事中もやってましたね。今じゃコンプライアンスがどうこうって言って難しそうですけどね。いい時代でしたね。\n
\n
川井　何年目くらいからRubyを作りはじめたんですか？\n
\n
Matz　1993年2月なんで入社して3年目の終わりくらいからですかね。\n
\n
川井　どれくらいの期間で形になったんですか？\n
\n
Matz　内輪にリリースしたのが94年の10月なんで、１年以上かかってますね。\n
\n
川井　それくらいで作ってしまったんですね。\n
\n
Matz　インターネットで広く皆さんに使ってくださいって言ったのが95年の12月ですから、それまでには3年くらいかかってますね。\n
\n
川井　コンピュータ言語を作るって想像がつかないんですけど、どういう流れというか工程が必要なんですか？\n
\n
Matz　私もそんなに言語を作ったことはかなったんで、今だから言えることなのかもしれないんですけど、プログラミング言語を作るって実はそんなに大変じゃないんですよ。\n
\n
川井　そうなんですか？\n
\n
Matz　いろんなところにフリーのソフトウェアのソースコードがあるんで、それを見ながら、ああ、こんな風にやるんだって言って、それをこっちに持ってきてとかRubyだったらこうするよねとかいう風に考えて、それで段々作っていくんです。最初はまずHello Worldを出したいと考えると思うんですけど、そうするとまずはプログラムが読み込めないと駄目ですよね。\n
\n
川井　そうですね。\n
\n
Matz　なのでプログラムを読み込む部分を書くわけですよ。そうすると、print &quot;Hello World&quot;は文法的に正しいとか文法チェックがまずできるんですよ。\n
\n
川井　なるほど。\n
\n
Matz　今度は、文字列を読み込んできて文字列オブジェクトを作らなくちゃならないんですよね。だから「&quot; &quot;」の間を読み込んできて、それをメモリ上にコピーして文字列を作るみたいなものを作るんですよ。すると文字列ができるんです。\n
\n
川井　はい。\n
\n
Matz　オブジェクト指向言語なんで、文字列っていうのはオブジェクトじゃないですか。文字列オブジェクトってことはクラスがいるよねっていうことになって、クラスがいるってことはオブジェクトクラスがあって、クラスツリーがあってと、どんどんと書かないといけないわけですよ。\n
\n
川井　はい。\n
\n
Matz　それが終わると、文字列オブジェクトできたってことになるんですが、でもまだ出力できないんですよ（笑）\n
\n
川井　（笑）\n
\n
Matz　なので、今度はファイル入出力するために、関数書いてクラスを書いたりするわけです。こういうのを続けていって、Hello worldが出た！って言ってたのが1993年夏ぐらいなんで、半年くらいかかってますね（笑）\n
\n
川井　目的のための積み上げていく感じですね。\n
\n
Matz　目的っていっても、Hello worldなんですけどね（笑）　Hello worldを出すために延々とやってた感じです。\n
\n
川井　なるほど。\n
\n
Matzでも、しばらくやっていくとメモリが減ってきて、ガーベージコレクターがいるよねってことになるんですけど、当時からあったBoehmGCっていうガーベージコレクターのライブラリをリンクしてみたら落ちちゃったんです。\n
\n
川井　あらら。\n
\n
Matz　なので、しょうがない、自分で作るかって言って、これまた何ヶ月かかけて自分で作ったりしてました。\n
\n
川井　ははあ。\n
\n
Matz　あとは文字列だけじゃ駄目なんで、整数がいるとか、配列がいるとかハッシュがいるだとかどんどん追加していくわけですよね。それでどんどん積み上げていって、ある程度使えるようになったかなというところまでで大体１年と10ヶ月くらいですかね。それで、今はほとんどなくなってしまっているNetNewsっていうメディアで、「こんなものを作っているんですけど、誰か手伝ってくれる人はいませんか？」って募集したら何十人か集まってくれたんです。\n
\n
川井　なるほど。\n
\n
Matz　それで、itojun（いとぢゅん）さんの好意でFTPサイトとメーリングリストを提供していただいて、何十人かで相談して作っていたんですけど、１年経ってもう少しましになったなってことでソースコードも含めてNetNewsで公開したのが、1995年の12月ですね。\n
\n
川井　なるほど。当時から関わっている方で、今でもコミュニティで活躍されている方っていらっしゃるんですか？\n
\n
Matz　例えば、一緒に本を書いている石塚圭樹さんは、もともと私の同僚でRubyを始めたときにも一緒にいた方ですが、今でも手伝ってもらっていますし、渡辺博文さんって方は、一番最初の頃にWindowsやDOSでRubyを動かすのを手伝ってくれたんですが、今でもお手伝いいただいています。\n
\n
川井　１つの言語がこうして皆さんの力も含めて出来上がっていくのって醍醐味がありますね。\n
\n
Matz　そうですね。とても自分だけでの力で作ったとは言えないですね。\n
\n
＜最初の転機＞\n
\n
川井　その間、仕事の方は変化はあったんでしょうか？\n
\n
Matz　Rubyを作り始めて次の年の1994年にあまりに景気が悪くて会社が傾くかもしれないと思って、いろいろと探していくつか面接は受けたんですが、やっぱり東京は駄目だと思って、オブジェクト指向のことも分かるし、C++も書けますっていう触れ込みで名古屋の会社に転職したんです。\n
\n
川井　何をやっている会社だったんですか？\n
\n
Matz　会社そのものはトヨタの子会社で、部品系のCADを作ってました。バックミラーのデザインなんかをするようなシステムを作ってました。\n
\n
川井　そういうものに興味はあったんですか？\n
\n
Matz　全然（笑）\n
\n
川井　（笑）やっぱり東京以外でっていう条件ですか？\n
\n
Matz　はい、東京以外でですね。それにオブジェクト指向もできるし。\n
\n
川井　やりたいことと住むエリアが優先なんですかね？\n
\n
Matz　そうですね。住む場所は東京以外ってレベルですけど。いずれにしても、やりたいことと住む場所は譲れなかったですね。ただ当時、景気が悪かったので、その条件は結構厳しくて大変でしたね。人材会社さんなんかにもお願いしたんですけど、東京なら紹介できるんですけどねって言われましたね。\n
\n
川井　そうでしょうね。\n
\n
Matz　当時はあまり考えなかったんですけど、今考えると、そういう逆張りをしたのはとてもよくて、つまり、鶏口と為るも牛後と為る勿れで、人がいないんで大事にしてもらえるんですよ。\n
\n
川井　なるほど（笑）\n
\n
Matz　単に東京の人混みが嫌だってだけだったんですけど、今思えば逆張りをしたことは、自分がハッピーなエンジニアライフを送るとか、Rubyを続けられるところで働くことができたっていう意味では成功だったかなと思いますね。\n
\n
川井　人と違うことをすることで道が拓けたということですね。\n
\n
Matz　「図らずも」人と違う人だったので（笑）\n
\n
川井　「図らずも」ですか（笑）\n
\n
Matz　もうちょっと他の人と同じだと思っていたんですけどね（笑）\n
\n
川井　（笑）\n
\n
Matz　最近は、諦めてます（笑）\n
\n
川井　キャリアというとやはり会社と仕事ではなくてプログラムとしてということになるんですよね？\n
\n
Matz　まあ、そうですね。でも会社は3社勤めましたが、3社とも恵まれていましたね。それなりに優遇してもらえましたし、理不尽な上司とか理不尽な仕事も、まったくなかったわけではないですが、嫌だと言えばちゃんと話は聞いてもらえましたからね。\n
\n
川井　ちなみに仕事上一度もネクタイをした経験はないんですか？\n
\n
Matz　いえいえ、１社目はスーツの会社だったので、ずっとスーツにネクタイで会社に行ってました。3年くらい経ってたまたまみんな大掃除か何かでトレーナーにジーンズのようなラフな格好で出社した日があったんですけど、どうせお客さんと会うこともないしって思って、翌日もそのままの格好で出社してみたんですが、誰も何も言わないんですよね。\n
\n
川井　（笑）\n
\n
Matz　友達には、「どうした？」って聞かれたので、「自主的にカジュアルで」と言ったら、「そうかあ」って感じで、上司も何も言わないんで、「ああ、いいんだ」って思ってそのままカジュアルになりました。私の事業所は400人くらいいたと思うんですけど、１人だけTシャツとジーンズとかそんな感じでしたね（笑）\n
\n
川井　最初の一人って貴重な存在ですよね。\n
\n
Matz　それ以来、お客さんとの打ち合わせなんかは別ですが、職場ではスーツは着ていないですね。\n
\n
川井　スーツのイメージがまったくつきません。\n
\n
Matz　いえいえ、私は日曜日の教会にはスーツでいきますからね。教会の人は私のことをスーツを着ている人って思ってますよ。\n
\n
川井　へえ、そうなんですね。\n
\n
Matz　それでいて職場では着ないので、教会の帰りにスーツ姿で会社に寄ったら、なんか珍しいものを見るような目で見られましたね（笑）なので別にスーツを着ないわけじゃないです。\n
\n
川井　なるほど。スーツは着たくないってわけではないんですか？\n
\n
Matz　あまり長い時間着ているのは嫌ですね。\n
\n
川井　教会はスーツで行くものなんですか？\n
\n
Matz　カジュアルじゃなくてフォーマルってことになっているのでスーツにネクタイですね。皆さん、私の１面しか知らないって感じですね。\n
\n
川井　（笑）\n
\n
Matz　人間は多様性があっていいと思うんですよ。\n
\n
川井　そうですね。\n
\n
Matz　一昨年、経済産業大臣表彰をいただいたときは、皆んな、ぴしっとしたスーツで、私だけがTシャツとジーンズで副大臣から表彰状をもらいました。\n
\n
川井　そこはフォーマルじゃないんですね。\n
\n
Matz　そうですね。私の場合は、副大臣から表彰を受けるよりも教会の方がフォーマルですね。\n
\n
川井　そういうことですよね。\n
\n
Matz　（笑）\n
\n
川井　名古屋の会社には何年くらいいらしたんですか？\n
\n
Matz　名古屋の会社には、4年弱ですかね。\n
\n
＜２度目の転機＞\n
\n
川井　また転機があったんですか？\n
\n
Matz　2つほどあって、私のチームは造船の仕事をしていたんですが、日本財団がスポンサーの大きなプロジェクトで、ミーティングが毎週東京だったんですよ。それで偉い人の判断で、東京事務所もあるし、皆んなで東京に行こうってことになってしまったんです。それで私は「東京が嫌でこの会社に入ったのに東京に行ってどうするんですか。私は嫌です」って言ったら一人だけ置いていかれてしまったんです。\n
\n
川井　（笑）\n
\n
Matz　それで、他の人たちは東京に机を置いて、私だけは名古屋の別のプロジェクトの片隅に机を置かせてもらって、普段はネットでやりとりをして週に１回だけ東京にミーティングでいくという生活になって半年くらい続けましたかね。流石にこれはやばいのではと思ったんです（笑）\n
\n
川井　そりゃ、そうですよね。\n
\n
Matz　別に誰にも何も言われなかったんですけどね（笑）\n
\n
川井　（笑）そうは言ってもってことですね\n
\n
Matz　（笑）はい、そうは言ってもやばいかもしれないってことです。それが一つで、もう一つが、私の知人を通して、島根でLinuxを中心に会社を立ち上げる人がいるという話を聞いたことでした。実家に帰ったついでに話を聞いて、私みたいな人が来てくれたら嬉しいってことだったし、会社での立場もやばくなっていたし（笑）、Linuxやフリーソフトウェアの仕事ができるところは日本中探してもあまりないだろうと思って。新規起業は不安だけど，まあ、2年くらいはなんとかもつだろうと思って島根に移ってきたのが1997年です。もう12年前になりますね。幸い2年で駄目にならずにずっともってます（笑）\n
\n
川井　ちょっと下世話なことをお聞きしますが、転職の度に収入はUPしているんですか？\n
\n
Matz　最初の転職のときには収入は明らかに上がりました。2番目の転職のときにも収入は下がっていないですね。\n
\n
川井　するとやりたいことも実現できて、収入の面でもハッピーなエンジニアライフを送っているということですね。\n
\n
Matz　そういう意味では仕事の面でも収入の面でも恵まれていると思いますね。逆張り戦略正解ですね。\n
\n
川井　名古屋の会社にいた際は、Rubyはどういう風に進めていたんですか？\n
\n
Matz　Rubyはやっていましたね。会社のHPを作っている管理者が同僚だったので、会社のHPの下にRubyっていうページを作らせてもらって、FTPサーバーも立ち上げてもらってました。当時はおおらかでしたね。\n
\n
川井　おおらかすぎます（笑）\n
\n
Matz　会社のネットも、たぶん半分くらいは私のトラフィックだったんじゃないかと思うんですけど、上司とかは誰も気がつきませんでしたね（笑）\n
\n
川井　コミュニティ活動自体を会社に持ち込んでやっていた感じですね。\n
\n
Matz　そうですね。会社のサーバーを使ってやってましたね。\n
\n
川井　その間に大きな動きはあったんですか？\n
\n
Matz　そうですね。ドキュメントを翻訳したのもその会社にいたときでしたし、海外からアクセスが来たのもその当時で、知る人ぞ知る的な感じでした。当時はメーリングリストもその会社のサーバーを借りてやってましたね。\n
\n
川井　いい時代ですね（笑）\n
\n
Matz　いい時代でした（笑）\n
\n
川井　ネットワーク応用通信研究所（以下、NaCl）に入られたときはRubyを仕事にするっていう気持ちはあったんですか？\n
\n
Matz　Rubyを仕事にするって言える時代ではなかったので、Rubyをやっているということを認めてくれますかという条件で転職しました。Rubyをやっているだけでは儲かりませんからね。\n
\n
川井　許可してもらえるかってことですね？\n
\n
Matz　そうですね。\n
\n
川井　NaClに入ってからはどんな仕事をしたんですか？\n
\n
Matz　そうですね、適当に普通のプログラミングの仕事もすれば、Rubyの作業もするみたいな感じでいたんですけど、よく分からないうちに段々Rubyの割合が増えてきて、会社も軌道に乗ってるし、まあいいかみたいな感じでRubyの方ばっかりやってましたね。\n
\n
川井　それは普通の人がこなすミッションを早く終えてしまってRubyをやっていたのか、ミッションをやらないでRubyをやっていたのかでいうとどちらなんですか？\n
\n
Matz　よく分からないですね。ただ言われたことはとりあえずやっていたような気がするんですけど、NaClのときはあまり意識してはいなかったですね。名古屋の会社の時は、仕事に納期があって、朝の通勤時間に電車でノートパソコン開いて会社の業務をこなして、会社についたらRubyをやって、また帰りの電車の中で会社の業務をしてってやっていたらなんとか納期に間に合ったっていう感じでしたね（笑）\n
\n
川井　（大笑）そりゃ、並はずれて早いってことですね。\n
\n
Matz　まあ、納期設定も自分でしていたので、そのあたりも盛り込んで設定していたのもありますけどね。\n
\n
川井　その納期設定が否定されないわけですよね？\n
\n
Matz　そうですね。明らかに遅いとは言われなかったですね。\n
\n
川井　やはりそういう裏付けがあるからできることなんでしょうね。\n
\n
Matz　そうかもしれませんね。\n
\n
川井　NaClに入ってからはRubyについてはどんな感じだったんですか？\n
\n
Matz　淡々とやってきたらここにいたという感じなんですが、名古屋時代から書いていた本を出しました。本の原稿って結構大変で、雑誌の場合は締め切りがあるので書かないといけないっていうのがあるんですけど、本ってそういうのがないんで、なかなか進まないんですよね。出版社の人に頼まれて「書けるかもしれない」って思って引き受けても「やっぱり何年たっても終わりません」っていうことも多々ありましたね（笑）\n
\n
川井　（大笑）\n
\n
Matz　そういうことにもめげずに一生懸命に頑張って1999年に最初の本が出て、これが結構売れたんです。売れたっていっても一般書に比べれば全然なんですが、コンピュータ関係の書籍って１万部売れたらベストセラーみたいな感じなんです。それでも１万数千部出て、その年のコンピュータ書籍のベストセラーになったんですよ。こんな本誰が買うんだって思って出したんですけどね。\n
\n
川井　いえいえ。\n
\n
Matz　それで2000年に英語の「Programming Ruby」通称ピッケル本が出るですが、これもびっくりでしたね。同じ年にオライリーからRubyデスクトップリファレンスを出したり、そんな感じでRubyの本も段々揃ってきて、2001年から2002年にかけては第一次Ruby本ブームみたいな感じでいろいろな本が出ましたね。その2年ぐらいの間に30冊くらい出たんじゃないですかね。\n
\n
川井　すごいですね。\n
\n
Matz　ただその時は一過性のもので、やはりRuby本をいくら出しても売れないっていうことで、しばらくは国内の出版社は一切出さなくなったんですけど、2005年くらいからまた状況が変わって出始めて、今では私でも把握しきれないほどですね。\n
\n
川井　すごい量ですよね。\n
\n
Matz　初期の頃は全部買ったり、献本していただいたりしてましたが、最近は全部は揃っていないですね。\n
\n
川井　こうしたRubyのブレイクにはRailsのヒットが大きかったと思うのですが、まだまだRubyを後押ししようという企業が本格的に出てきていないのが、更なるブレイクのネックになっていると思うんですが、いかがでしょうか？\n
\n
Matz　確かにそうですね。Rubyだけでご飯が食べられるのは私だけという状況で、それでも中には生活のバランスを崩しそうなくらい頑張っている人もいるので、そういう人たちを支えられたらいいなという気持ちはありますね。\n
\n
川井　うちもまだ小さい会社なので、資金的に大きな投資はできないんですが、地道な活動を続けていこうとは思っています。\n
\n
Matz　そうですね。関わり方はいろいろあると思いますね。最近だとRuby Gemみないなライブラリがたくさんありますけど、まだ1.9に対応していないものも多いのでそれを1.9対応にするということも大きな貢献ですし、バグを見つけたり直したりという貢献もできるでしょうし、あとリファレンスマニュアルを書いているプロジェクトがありますが、これはまだ分かりにくいというコメントを出すだけでも大きな貢献じゃないかなと思いますね。できることはたくさんあると思います。\n
\n
川井　そうですよね。\n
\n
Matz　ただヒューマンリソースが足りないからできてないこともたくさんあるので、他の言語のコミュニティなんかをRubyの良さを損ねない範囲内で真似したいし、それに必要なお金とか人材がぼつぼつ集まってきたら嬉しいなと思いますね。\n
\n
川井　なるほど。\n
\n
Matz　ただビジネス的に冷静な判断をすると、Rubyってそこら辺に転がっているものなので、それに投資をするって奇特な人は、正直それほどいないと思うんですよ。ただ今後、裾野が広がっていく中では、粋狂な人がいて助けてくれたりということもあると思うので、裾野の拡大を阻害するようなことにはならないように気をつけておくということが必要なんじゃないかなと思いますね。\n
\n
川井　Rubyってある意味、ご自身の子供みたいなものだと思うんですが、段々いろんな人が関与してくると自分自身で関われる部分が減ってくると思うんですが、そのあたりってどう感じているんでしょうか？\n
\n
Matz　まあ、そうですね。でも一番楽しいところは押さえてるんで（笑）、それはそれでいいかなと思いますね。\n
\n
川井　本当の子供みたいに自我が芽生えてどこかいっちゃうなんてことはないんですかね？\n
\n
Matz　まだ16歳くらい、高校生ぐらいですからね。\n
\n
川井　反抗期はもう終わったくらいですか？\n
\n
Matz　反抗期はまだまだですね（笑）　実はちょうどRubyより１歳上の娘と、１歳下の娘がいるんですよね。\n
\n
川井　じゃあ、3姉妹なんですかね。\n
\n
Matz　娘はもう一人いるんで、4姉妹でしょうね。\n
\n
川井　よく名前重要って言ってますけど、「Ruby」ってネーミングは絶妙ですよね。\n
\n
Matz　ありがとうございます。まあ偶然ですけど（笑）\n
\n
川井　これってきっかけがあるんですか？\n
\n
Matz　いえ、特にはないですね。Perlが宝石だから宝石にしようかぐらいな感じですかね。DiamondとかSapphireって長いよねってことで、候補に挙がったのがRubyとCoralだったんですけど、CoralよりはRubyがいいよねってことでRubyになったんです。\n
\n
川井　そうだったんですね。\n
\n
Matz　誕生石の話とかもありましたけど、決まってから、そういやそうだよねみたいな感じだったと思います。\n
\n
＜これからのRuby、これからのMatz＞\n
\n
川井　今後、Rubyをどうされたいかお聞きしてもいいですか？\n
\n
Matz　今後、Rubyをどうするかですか。。。「ランボー」って映画の最後でランボーが「日々を生きます」って言うんですけど（笑）、あんな感じですかね。\n
\n
川井　（笑）ご自身はどうですか？\n
\n
Matz　私もやっぱりこのままでいくつもりですね。事業がどうこうとかお金の勘定がどうとかあまり高望みはしてないんですよ。とりあえず、食べていけるだけの収入はあるし、Rubyはまだまだ楽しそうなことがあるんで、ここから先10年から20年ぐらいは、これを続けていきたいなと思いますね。\n
\n
川井　何か新しいことをやりたとか、新しいものを作りたいとかってあるんでしょうか？\n
\n
Matz　Rubyを離れてまでやろうってものはないですね。\n
\n
川井　新しい言語を作ろうとかもないんですか？\n
\n
Matz　今のところはないですね。プログラミング言語って本当に寿命が長いんですよね。まだ第二世代くらいなんですよ。第一世代がFortran、Lisp、COBOLあたりで、第二世代がCとかPascalぐらいなんですけど、Rubyは第三世代って言えるほど進化してないんですよ。\n
\n
川井　そうなんですか。\n
\n
Matz　50年で2.5世代とか3世代進むとかなんで、もうちょっとかかるかなと（笑）\n
\n
川井　すると生涯、Rubyをやろうという話ですよね？\n
\n
Matz　とりあえず思いつかないんで（笑）\n
\n
川井　（笑）\n
\n
Matz　思いついたらすぐに変わるかもしれません（笑）\n
\n
川井　（笑）\n
\n
＜エンジニア向けてのメッセージ＞\n
\n
川井　最後にエンジニアに対するメッセージをいただけますか。\n
\n
Matz　いつもエンジニアライフ的な講演で話すのと同じなんですけど、他の人と同じでなければいけないっていう圧力に対してもっと鈍感であってもいいんじゃないかなって思いますね。今日もいろいろ話してきましたけど、私がうまくいったのって大概逆張りをしたときなんですね。仕事は東京の方がいっぱいあるんだけど東京じゃないところで働いたとか、みんなはソフトウェアで商売をしようとしてるんだけど、私はオープンソースできましたとかですね。\n
\n
川井　はい。\n
\n
Matz　どの分野においてもマイノリティであったことが私の成功の理由なんじゃないかなって思いますね。実は狙ったわけじゃないんですけどね（笑）、プログラミング言語を作ろうという人はあまりいない中を突き進んできたり、東京に仕事はいっぱいあると言われたけど、自分の仕事は１つでいいので、地方で働くことにしました、とかが結果的にはよかったんで、下手な安心感よりは逆張りするということが成功するためには有効なのかなと思います。\n
\n
川井　なるほど。逆張りした環境に入ってから必要なスタンスってどういうスタンスですか？\n
\n
Matz　「自発」が大事なんじゃないかなって思います。口を開けて待っている人ってこの業界にたくさんいると思うんですけど、自分が何をしたいのかとか自分が何を学ぶのかってことは他の人には聞いてはいけないと思うんですよね。その人の人生はその人自身の人生じゃないですか。私を含めて他人は無責任なんですよ。だから私は他人の人生に責任はとれないので、どうすべきかってことは言えないんです。その人の内側から出てくるものがあるときにだけ成功するんじゃないかなって思いますね。\n
\n
川井　なるほど。\n
\n
Matz　逆に自分に内側から何かを出すことができないんだったら、出すことができる分野を見つけるまでは、結構しんどいかなって思います。\n
\n
川井　自分の進むべき道が今やっていることではないかもしれないってことですね。\n
\n
Matz　それって能力とは関係ないんですよ。勿論、コンピュータサイエンスの勉強をしていた方がいいし、知識もあった方がいんだけど、それよりもなによりも自発的に何かするって気持ちがあれば、そういうのはついてくると思うんです。\n
\n
川井　確かにそうですね。「自発」がキーワードですね。\n
\n
Matz　ですから内側から自然に出てくる何かがエンジニアとして差別化する材料じゃないかと思うんですよ。それにプラスして成功するには自分を見つめるとかゴールを設定するとかっていう戦略とかってありますよね。でも、なによりも重要な動機づけっていうのは、他の人には分けてあげられないんですよ。命みたいなもんで、「私は命は2つ持ってきた」というのは現実的にはないんで・・・っていうといつもうちの奥さんに「あなたは人の分からない話をする」って怒られるんですけど、野暮を承知で解説すると初代ウルトラマンの最終回に、「私は命を2つ持ってきた」っていう台詞があるんですよ。ウルトラマンがゼットンに負けて死んだあと、ゾフィーがやってきて言うんですけどね。\n
\n
川井　ありましたね、それ。\n
\n
Matz　うちの子たちもそういう古いネタばっかり知ってるんですよ（笑）\n
\n
川井　（笑）\n
\n
Matz　このあたりは適当に編集してください（笑）\n
\n
川井　（笑）いえいえ、面白いのでそのままでいきます。本日はどうもありがとうございました。\n
\n
Matz　こちらこそありがとうございました。\n
	</item>
	<item>
これまでに作ったもの\n
\n
　ハッカーは、「作ったもの」によって評価されるのだと思います。最近では「Rubyのまつもと」として知られるようになってしまったわたしですが、そのほかにも以下のようなものを作ってきました*。いままで作ってきたものは、「ハッカーとしてのわたし」を表現しているような気がします。\n
\n
Emacs Lispによるメールリーダー「cmail」\n
\n
　cmailは、もともと山梨大学（当時）の林さんが開発されたメールリーダーです。学生時代のわたしは、自分が使いやすいようにcmailをいろいろ改造して使っていたのですが、あるとき「フリーソフトウェアなんだし、せっかくなので改造を本家に還元しよう」と思い立ちました。林さんにメールを書いたら、「わたしはもう使っていませんからご自由にどうぞ」というお返事をいただき、わたしが引き取ることになったのです。わたしにとって最初のフリーソフトウェアということになります。その後cmailは、コミュニティーの協力を得てさまざまな新しい機能が追加されました。MIME*対応、GPG*対応、3ペイン表示、IMAP*対応などなどが追加され、発展を続けたのです。わたしは数年前にメンテナを引退しましたが、昨年新しいメールリーダーmorq（後述）に移行するまでは、実に14年もの間cmailを使い続けていたことになります。\n
\n
日本語が使えるXView風GUIライブラリ\n
\n
　また、XView*に似たGUIライブラリを作ったこともあります。これは、以前勤めていた会社（独立系ソフトハウス）で社内OAシステムを作っていたときのことです。「日本語が使えるGUIツールキットのソースコードが手に入らない」という口実のもと開発しました。日本語が使えないなんて、GUIライブラリの国際化が進んだいまでは信じられないですが、もう14～5年も前のことですから。当時はまだMotif*とOpenLook*の対立が盛んなころでした。OpenLookの方が優れていると感じたわたしは、OpenLookのツールキットであるXViewを参考にAPIをデザインしたのです。\n
　ただし、作ったのは単なるGUIライブラリではありませんでした。まずObjective-C*風のメッセージ呼び出しの仕組みとクラスライブラリ（OrderedCollectionとか）を作って、その上にGUIツールキットを構築しました。ウインドウやボタンのような部品も、そのオブジェクト指向ライブラリのクラスとして実装したのです。あのころ、わたしは若かったなあ。実は、このライブラリのごく一部はRubyに流用されています*。\n
\n
オブジェクト指向データベースクラスターの分散ガベージコレクション\n
\n
　これは10年くらい前の仕事です。ObjectStoreという、C++のオブジェクト指向データベースを使ったシステムを開発していたのですが、メモリ管理を自動化したいという要求に応えるため、\n
同一データベース内ではマーク＆スイープ方式\n
データベースを超えた参照（external reference）はリファレンスカウントを使う方式\n
という分散ガベージコレクタを実装しました。ネットワーク上に分散したデータベースの位置を管理するため、小さな中央サーバを用意したのですが、この部分はRubyを利用しました。ソケットプログラミングが非常に楽で重宝した覚えがあります。\n
\n
検索ベースメールリーダー「morq」\n
\n
　2004年から2005年にかけて久しぶりに開発したアプリケーションが、メールリーダーmorq*です。\n
　morqはGmailの影響を受けて開発されました。大量のメールが届く昨今では、メールを分類するという行為は遠からず破たんします。これからはGmailのような全文検索ベースのメール管理法が有効だと考えました。しかし、Gmailには「ネットワーク接続がないと使えない」、「1Gバイトの容量制限（当時）は将来的に不安」という欠点があります。しかし、ふと見ると手元のPCにはまだ数Gバイトの空きがあるではありませんか。ハッカーたるもの、なければ自作すれば良いのです。そういうわけで作ったのがmorqです。バックエンドがRuby＋全文検索エンジン「Rast」。フロントエンドがEmacs Lispでできています。\n
　わたしはもうかなり長い間、morqをメインのメールリーダーとして使っていますが、なかなか快調です。「確か先月ごろ、こんなフレーズを含むメールがあったよな」というおぼろげな記憶からメールを見つけ出し、そのメールを含むスレッドを一度に読むことができます。人間が幾らこまめに分類しても、数万から数十万通のメールからこの速度で目的のメールを見つけ出すことはできません。\n
　morqはRastのパッケージに同梱されています。こちらのサイトからRastの最新版を入手してください。2007年3月28日現在では、Rast 0.3.1が最新版です。\n
\n
ハッカー人世訓\n
\n
　ハッカーの定義はあいまいなものです。ハッカーとは、「ハックする人」以上の意味を持たず、むしろある種の性格分類だからです。その性格がプログラミングに向かうとき、人はその人をハッカーと呼びますし、分野が違えば「異端者」、「改革者」、「革新派」などと呼ばれることでしょう。\n
　さて、そのようなハッカーが幸せに生きるための、人世訓のようなものを幾つか紹介しましょう。幾つかは、わたしの「ハッカー人生」から直接学んだものです。\n
\n
「できない」と言わない。「やらない」と言う\n
\n
　プログラミングの世界で不可能なことはめったにありません。制限は時間と手間と知識の限界だけです。ですから、いつでも「やればできる」のです。こう考えれば「やりたいことをやらない」理由が減ります。\n
\n
欲しいものがなければ自分で作ろう\n
\n
　何かを作ろうとしたとき、世の中に同じものがすでにあるなら無駄になります。そのような無駄は「車輪の再発明」として嫌われます。しかし、車輪が存在しないとき、あるいは自分ならもっと良い車輪が作れると感じたときには、ためらわずに作り始めるのがハッカーというものです。ちょっと偉くなると、自分で作る代わりに部下に作らせたりします ;-）。\n
\n
制約を打ち壊せ\n
\n
　あらゆる制約はハッカーの敵です。自分の能力、意思、行動、言論への制約により不愉快な思いをするときには、それを取り除くべく行動するのがハッカー的です。フリーソフトウェア運動も、オープンソースも、そのようにして発生しました。ただ、あまり過激になって非合法活動（クラッキングとか）に身を落とさないよう、ここでは忠告しておきます。\n
\n
コミュニケーションを忘れない\n
\n
　ハッキング能力とコミュニケーション能力は比例しません。しかし、ハッカーとして「作品」を一人で完成させることができる人は稀です。ですから、（例え苦手でも）コミュニケーションに時間を取ることが、ハッカーとして「成功」するのに役立ちそうです。\n
\n
まとめ\n
\n
　大学卒業以来、「ハッカーでも社会人として生きていける」ことを目標に生きてきました。いまのところ何とか実現できているようです。皆さんもハッキングと幸せな生活を両立させてくださいませ。Happy Hacking!\n
	</item>
	<item>
まず、己を知り、戦略を立て、行動すべき\n
\n
　景気の不透明感がいっそう強まる現在、企業に右肩上がりの業績・成長を期待できない。こうした時代に個人ができることはなんであろうか？\n
　「黙っていても業界や市場が伸びていた時代には特に何も考えなくてもそこそこいけたが、現在は戦略がなければ生き残れない。まず、己を知ることが重要になる。自分は何が得意で、何が欠点なのか。妥協できること、譲れないことは何か」を明確に判別するべきだと、まつもと氏は指摘する。同氏の場合、大都会になじめず、現在は島根県に在住している。これはどうしても妥協できないことだった。\n
　楽しく仕事をするためにも「自分を知らなければならない。自分にとっての幸せとは何か。金持ちになる、世間から評価される、有名になる、好きなことをやっていられるだけでよい、という例もあり、人によって異なる。暖かい家庭を築く。田舎で暮らすこと」などいろいろある。\n
　そこで「目標を決め、戦略を考え、これにしたがって行動すれば、幸せになる確率は高くなるのでは」という。仕事が楽しくないのは、これらが不明確だからだというわけだ。\n
\n
機嫌がよく、コミュニケーション上手であれ\n
\n
　専門知識は必須だが、それ以上に、表現力、コミュニケーション能力が重要になるという。\n
　「理系にもかかわらず、私は高校の頃から数学が苦手だった。大学では泣き落としで、レポートで単位をもらったこともある。ただ、コミュニケーション力はごく普通の理系の学生よりも上で、これが成功の要因になった」。\n
　ITは技術や機械ばかりが対象ではなく、実は「ネットの向こうには人がいる。クライアントに依頼を受けソフトを開発する。やはり人間関係が大事」だからだ。\n
　「コミュニケーションのしやすい人のところにラッキーが舞い込んでくる」（まつもと氏）\n
　成功するための戦略のひとつは「周りの人々と同じことばかりしないこと」だ。「（多数の人と違うことはすべきでないという）無言の圧力は幻想と思って良い。（人と異なることをしても）それほど摩擦は起きない」。\n
　また、「自信をもって言うべきことは言って、一味違うと思われること。ただ、実力を伴わないといけないが、理不尽なことに対してはクレームする勇気をもつべき」。\n
　さらに「機嫌がよい」ことも成功の秘訣という。\n
　「不機嫌は損だ。円滑なコミュニケーションが重要。不機嫌は周囲の人間も不機嫌にする。誰も機嫌の悪い人に仕事を頼んだり、いっしょに仕事をしたいとは思わないだろう。技術とは関係のないことだが、成功につなげるには大事なことだ」\n
　無論、「100人のうち100人が成功する方法はない」が、「このことならあの人に聞けば分かる、という分野があれば強い。好きなことを継続して何年もやっていれば、誰にも負けないようになる。（逆に言えば）好きなことでないと続かない。自分のことをよく知って、自分で行動を起こすこと」。これが「まつもと的」な、成功へのてがかり、といえる。\n
	</item>
	<item>
今、「世界で最も注目を集めているプログラミング言語はRubyである」といっても、過言ではないだろう。Rubyは、言語そのものの 持つ自由さ、柔軟さに加え、Ruby on Railsという強力なオープンソースフレームワークのヒットも手伝って、世界中のプログラマーを惹きつけている。そんな魅力的な言語を開発したのが、ま つもとゆきひろ氏だ。\n
まつもと氏が、プログラミングの世界に足を踏み入れたきっかけはなんだろうか。\n
\n
プログラミングを学ぶ上で大事なことは「続けること」\n
\n
「実は、中学生のときに父親が買ってきたポケットコンピュータが最初なんですよ。400ステップぐらいのBASICが動く小さいやつで す。父親が自分でやろうとしていたのを、とりあげちゃってはじめたのがきっかけですね。」\n
きっかけは小さなことかもしれない。しかし、彼のプログラミングを学ぶことに対する姿勢は、今日の成功を予感させるものを感じる。\n
「プログラミングを学ぶ上で大事なことは、途中でやめないこと。ソフトウェアはやればできるみたいなところがあるけれど、実際できない というときの理由は、続かないからなんですよ。」\n
プログラミングは地道な作業かもしれない。初心者は、知る喜びから作る喜びに至る過程で、挫折してしまうことが多いのは事実だ。ゴール に到達したときにはじめて得られる喜びが、次に進もうという意欲に結びつくのだろう。しかし、昨今の大規模化、高機能化、複雑化したコンピューティング環 境は、ゴールを遠ざけてしまったようだ。\n
「特に、僕が子供のときには、400ステップしかない、今でいうと400行しか入らない、だから、小さく始めるしかなかった。例えば、 ゲームでも作ろうかっていうと、昔は、キャラクターがピコピコ動くぐらいのものだったけど、今は、ファイナルファンタジーとか、とてもひとりで作れるもの ではないでしょう。そういう意味では、今の子供たちは不幸かな。身近なところにゴールがない。でも、小さくはじめて大きくつくるのがいいところ。ぜひ続け てほしい。」\n
\n
Ruby誕生にも「続けること」があった\n
\n
まつもと氏がプログラミング言語をつくりたいと思ったのは、高校生の頃からだそうだ。\n
「その頃は、わけも分からず作りたいと思って挑戦し始めたんですよ。でも、言うのは簡単だけど、使い物になるものを作るまでは大変で、 なかなかできずにいました。でも15年ぐらい前かな、何回目かの挑戦でうまくいって、それがRubyだったのです。」\n
個人的な興味から生まれた言語「Ruby」。しかし、それが今や世界で注目されている。実際本人はどう感じているのだろう。\n
「正直、『びっくり』って感じです。ガートナーが2013年には、Ruby開発者が400万人ぐらいに増加するというという予想をして いて、根拠は分かりませんけど、『いやぁ、すごいことだなぁ』と思いました。」\n
\n
																							Rubyの将来はどうなるのだろう。\n
\n
「ひとつは性能を向上させたいです。今使われているほとんどのジョブのためには、Rubyは十分に性能がある気がしています。でも、 よーいドンで競争すると、その差が本当に重要かは別にして、カタログ上のスペックで劣ることが多々ある。それで採用されないというのも不本意なので、性能 向上はやっていきたいです。それから、今後、いろんな意味で、ソフトウェア開発のスケールがあがっていくでしょう。なんでもできるRubyの自由奔放さ は、個人で開発するにはいいけど、チームでは、迷惑をかけるかもしれない。こうした状況でもコントロールできる方法を探究していきたいと思っています。」\n
\n
企業での利用が広がるRuby\n
\n
RubyはRuby on RailsとともにWebアプリケーション開発で使われることが多い。教育や分析などで使われることも多いという。\n
「複雑じゃないんだけど、手早く作りたい。そういうところには、Rubyは向いています。銀行の勘定系などで、数千人のプロジェクトと かいうところでは、使われないだろうと思います。でも、最近では、開発を始めた頃には使われないだろうと思っていたようなところにも使われ始めています。 コンピュータの性能向上によって、どんどん状況は変わっていくだろうと予想しています。」\n
企業での採用を促進するには、企業側のナレッジ、ツールなどの環境、サポートなども重要だ。\n
「元々Rubyは、ハッカータイプというか、ほっといてもプログラミングできるような人たちから広まってきました。そういう人たちに ツールは要らない。でも、企業に広まっていくと、IDEが必須になります。僕は、Turbo Cとかでプログラミングを始めたので、ボーランドとその血脈のツールには非常に親近感があります。また、商用の安心感もありますし、3rdRailには期 待したいです。」\n
学校教育で輩出されるRuby経験者も重要だ。近年、大学でRubyを使っているところが増加している。\n
「卒業研究などでRubyを使う学生が増えてきています。『僕、Rubyわかります』って新入社員が増えてくることが、企業でRuby が広まっていくことにプラスに働くと思います。」\n
企業での採用では、Rubyの特性を理解しておくことも重要になる。注目されている言語なだけに、うたい文句に踊らされないように注意 も必要だ。\n
「自分でRubyを作って、Rubyはいいものだと思っているけど、万能だと思っているわけではないです。例えば、Java、PHPで 作っていたものをRubyに置き換えれば、なんでもハッピーということはない。移行のコスト、Rubyの流儀を学ぶコストも考えないと。過度な期待を抱い てやみくもに採用するのではなく、Rubyのいいところを理解してそれを活用してほしいですね。」\n
まつもと氏は、ネットワーク応用通信研究所（NaCl）のフェローという立場で、自由に研究・開発活動に従事している。Rubyの開発 や、Ruby関係の講演活動、執筆、取材などによって、Rubyの発展に努める日々を送っている。\n
	</item>
	<item>
■過大なブームから安定した成長へ\n
－ ご自身が作りだしたブログラミング言語が世界中で使われていることについてどうお感じですか。\n
　 また、Rubyの成長段階は現状どのあたりだとお考えですか。\n
まつもと：Rubyを作ったのはもう17年も前なのですが、その頃はこんな風になるとは全く思っていませんでした。個人的なデータ処理を行うために作ったものだったので、エンタープライズシステムの開発でRubyを使うなんて思いもしませんでしたから。\n
2004年にRuby on Railsが公開されてから、Rubyに対する注目度が高まってきました。2008年くらいまでは\n
一種のバブルのような感じで、実態以上に過大な期待をされていた部分もありました。2009年くらいから実\n
態を踏まえて、「これはいい」と思って使ってくれる人が増えてきた感じがします。過大なブームは終わって安定的な成長期に入った、といったところでしょうか。バブルがはじけなくて良かったです。（笑）\n
\n
■Rubyが優れている点、改善が必要な点\n
－ プログラミング言語としてRubyが優れている点、改善が必要な点を教えてください。\n
 \n
Rubyアソシエーション\n
理事長　まつもとゆきひろ氏\n
まつもと：優れている点としての一般的な評価は、生産性の高さと言われています。\n
2004年にRuby on Railsが発表されたときのデモビデオがそれを端的に示しています。そのビデオでは、データベースなど何も準備していないところからブログソフトを15分で作ってみせたのです。ページデザインなどの見栄えはもちろんできていないのですが、日付表示やコメント入力欄など必要な情報は盛り込まれていて、実際にコメントを入力してみると、きちんと表示されました。2004年の時点でWebアプリケーションを15分で作成するのはまさに驚異的だったので、当時とても話題になりました。\n
Ruby on Railsの良さは、Rubyの生産性の高さを最大限に活用した点にあります。Rubyそのものが持っているパワーをRuby on Railsが活用して、それによって非常に高い生産性を実現したということがいえるでしょう。発表から6年経った今でも、Ruby on Railsの生産性の高さは高評価を受けています。\n
一方、改善が必要な点としてよく言われるのがパフォーマンスです。\n
全く同じ処理を行うソフトウェアをJavaとRubyで作り、同時に処理をスタートさせると、処理時間に10倍以上の差が開くことがあります。Rubyの良さである生産性の高さはコードの簡潔性からきているのですが、それは人間がやる仕事（プログラミング）をコンピュータにまかせているということです。その分コンピュータが行う仕事は増えてしまうので、人間が一生懸命開発して作ったJavaのソフトウェアに比べてパフォーマンスが遅くなってしまいます。ただしRubyが最も使われているWebアプリケーションの分野だと、ネットワークやデータベースなどRubyが直接関係しない箇所がパフォーマンスのボトルネックになる場合がほとんどなので、課題ではあるけれども、クリティカルな問題ではないと考えています。\n
もう一点は、開発リソースの少なさです。\n
Rubyはオープンソースで開発されているので、開発者のほとんどがボランティアです。この技術を適用するとRubyはもっと良くなる、と分かっていてもリソースが足りない、といったことはありますね。 一方Javaなどでは大企業が優秀な人材をたくさん集めて開発しているので、リソースに関しての差は感じます。\n
\n
－ ボランティアは日本だけではなく、海外の方もかなりいらっしゃるのですか。\n
\n
まつもと：はい、そうですね。コミッターといってRubyのソースコードを自分の権限で変えることができる人が全世界で70人強いるのですが、そのうちの半分強が日本人で残りは他の国の方々です。ニックネームしか公開していない人もいるので、どこの国の人か分からない、という人もいますが。私や他のボランティアの誰とも会ったことない人もいますし。メールのやり取りだけなので、もし目の前にその人がいてもわからないでしょうね。\n
\n
－ リソースを増やすという意味では、認定試験は有効な手段と思われますか。\n
\n
まつもと：そうですね。1000人Rubyを使う人がいれば、その中に1、2名はもっと踏み込んでRubyに関わろうという人が出てくると思うので、裾野が広がるのは良いと思います。試験や教育を通じて裾野が広がっていくことによって、「Rubyをもっと良くしていこう」と考える人や企業が出てくることを期待しています。\n
■資格や認定試験は自分のスキルを理解してもらうための“言語”\n
\n
－2007年にRuby技術者認定試験制度がスタートし、10月1日から上位試験であるGoldが始まります。\n
　 試験問題の監修に参加されたそうですが、どのような知識を問う試験なのでしょうか。\n
\n
まつもと：SilverはRubyをスクリプト言語として使う、Rubyの各クラスの機能について理解している、といった基本的なレベルを問う内容でした。Goldはそれに加えてオブジェクト指向プログラミング言語としてのRubyの概念や、Rubyを使ってある程度の規模以上のソフトウェアを開発する際の知識を問うところにフォーカスして試験を設定しました。\n
GoldはRuby on Railsはカバーしていないので、Goldを持っているからRuby on Rails使えるという証明にはなりません。Ruby on Railsやソフトウェアの設計といったことまで踏み込んで、ということになると、より上位の試験が必要になってきます。今後Goldを取得する人が増えてくれば、もっと上のレベルの知識を証明したい、という声は出てくると思います。\n
ビジネス領域でRubyを使用しているエンジニアの方が、自らのRubyの知識を証明したいという欲求にこたえる形でSilverを提供したのが2007年でした。その後3年経ってSilverよりもひとつ上のレベルの知識を証明する必要が出てきたので、Goldを提供することになりました。これからも社会の要望にあわせて試験を提供していくというのが、Rubyアソシエーションのミッションの一つだと思っています。\n
\n
－ソフトウェアの設計を身につけるためには、どういった勉強をすればいいのでしょうか。\n
\n
まつもと：一概には言えないですね。設計の第一段階としてお客様の要望を聞き出すためのヒアリングは重要ですが、これについては特定の技法はありません。一方で、UMLのようなクラス設計が必要になることもあります。ソフトウェアやシステムの開発を行う場合、プログラミング言語の知識とは別に、設計手法は身につける必要があると思います。\n
\n
－Ruby技術者認定試験制度とUML技術者資格試験、UMTP UMLモデリング技能認定試験といった\n
　 組み合わせで取得すれば、言語と設計の両方のスキルを証明できますね。\n
\n
まつもと：それによって相乗効果がでる会社や部署は多々あると思います。\n
私の場合、今まで独学でプログラミングしているので、「プログラミングの勉強をしよう」「XXの技術を身につけないといけない」といったモチベーションを持ったことがないのです。資格が必要だという状況に陥ったこともありませんし。\n
しかし、今回Ruby技術者認定試験制度を始めるにあたって、さまざまなエンジニアの方々とお会いする機会があり、その結果資格の重要性が理解できました。どこかの会社に就職する際、まず人事担当者に会いますよね。面接時、「私はRubyができます」「プログラミングが上手です」といっても彼らは分かってくれません。\n
では人事担当者に自分のスキルを分かってもらうための&quot;言語&quot;、つまり方法は何？となったときに、「XXの資格を持っています」というのは説得力があると。履歴書に「Ruby Association Certified Ruby Programmer」と書いてあれば、第三者によって証明されたスキルですから、とても説得力があると思います。\n
システム開発などの技術に詳しくない人に対して、自分のスキルを理解してもらうための&quot;言語&quot;として資格や認定試験を活用してもらえれば良いのではないでしょうか。 \n
	</item>
	<item>
－ Rubyは実際どのような分野で使われているのでしょうか。\n
 \n
Rubyアソシエーション\n
理事長　まつもとゆきひろ氏\n
まつもと：1999年に最初のRubyの本を出版したのですが、そこに「Rubyが向かない分野」として、携帯のような小さいコンピュータとスーパーコンピュータのような大きなコンピュータと書いたのです。ところが最近は、これらの分野でもRubyが使われるようになってきました。携帯電話については性能が格段に進歩したせいもあって、携帯にRubyをのせましたという話を聞きましたし、スーパーコンピュータでは、異常気象の研究をしている方がデータ抽出の際にRubyを使用しているという事例を聞きます。\n
その他には、海洋ロボットに指示を出すのにRubyを使っていたり、イギリスのパブにあるワールドカップトリビアというゲーム機に使われていたり、RPGを作る市販ソフトでも使われていて、ゲームの世界にもRubyが広がっています。意外な例としては、スペースシャトルのチャレンジャー号の爆発に関するデータ分析にRubyを使ったということを聞いたことがあります。NASAでも使用されていたのには驚きました。「NASAで使われた技術」というと、なんだか通信販売のキャッチコピーのようですよね。(笑)\n
WebサイトでRubyを使っているところは本当に多いです。レシピサイトとして有名なCOOKPADは全てRubyで動いていますし。Webでいろいろと調べものをしているときに「こんなところにもRubyが使われているのか」と分かるとびっくりしますね。\n
\n
－ さまざまな分野で Rubyは使われているのですね。\n
　今後活用されると思われる分野はありますか。\n
\n
まつもと：先ほどの小さいコンピュータと大きなコンピュータの話でいうと、まず小さいコンピュータではDVDプレーヤーのようなデジタル家電です。デジタル家電の操作はソフトウェアで制御していることがほとんどですから、そこにRubyを活用できないかと。Rubyが動くレベルのコンピュータを家電に搭載しようとすると製品原価が上がってしまうため、現時点だと価格面で折り合いがつきません。けれども、徐々にコンピュータの性能は上がり価格は下がってくるでしょうから、数年のうちには実現するのではないかと思っています。\n
大きいコンピュータだと、高性能計算 (HPC: High Performance Computing)の領域ですね。こういったマシンを使う方は、天文の専門家や流体力学の専門家など、研究者が多いです。彼らはプログラマとしてはプロではありませんから、楽にプログラミングできて、本来の研究にすぐに取り掛かりたい、というニーズがあります。先ほどお話したパフォーマンスの部分が改善されれば、現実味を帯びてくるのではないでしょうか。\n
Rubyの生産性の高さを武器に！\n
\n
－Rubyを応援している地方自治体の話を耳にしますが、自治体での活用事例はありますか。\n
\n
まつもと：私が住んでいる松江市や島根県、福岡県がRubyを応援してくださっています。そういったところでは入札の際に「Rubyを使用すること」といった条件を設けるところも出てきています。 また、中国経済産業局や九州経済産業局のように、民間にRubyを使うことを奨励するように働きかけているところもあります。\n
自治体などが後押しするかどうかはともかく、Rubyの生産性の高さを武器にする企業が出てきてもいいと思います。一例として、島根県のホームページを管理するシステムの入札を紹介しましょう。 この入札では、Rubyで開発という条件がなかったので、市販のパッケージソフトを購入し、一部カスタマイズして納品する企業と、Ruby on Railsでゼロからつくって納品する企業の2種類の提案がありました。\n
島根県側の要求として、ハンディキャップを持った方への対応がありました。色や文字サイズの設定変更や、掲載内容の読み上げといった機能です。パッケージソフトを選択した企業は、そういった部分のカスタマイズに工数がかかることになってしまい、結果的にRuby on Railsでゼロから作って納品する企業の方が安かったのです。\n
また、島根県が行った別の入札では、Rubyで開発という条件が盛り込まれていました。大手企業は「責任を持ってRubyで開発できない」と判断して入札に応じなかったため、通常は大手企業の二次請け、三次請けを行っている企業が落札した、ということがありました。この企業は日頃からRubyエンジニアの育成に力を入れていたのでしょう。二次請け、三次請けの企業はもともとコスト意識が非常に高いうえに、さらにRubyの生産性の高さを生かして、かなり抑えた金額で提案したようです。\n
\n
－自治体の側からしても「この値段でできるのだ」と驚きますよね。\n
\n
まつもと：価格破壊が起こりますね。日本の硬直化したIT産業の構造を一部でも打破できた事例だと思います。Rubyの生産性の高さやオープンソースが、そういったキーテクノロジーの一部になりえる、というのは嬉しいことですよね。産業構造の正常化は、エンジニア個人の環境を変える一助にもなるのではないかと思います。\n
今までは一次請けの企業からの情報を元に開発を行っていたのが、発注元から直接要望を聞いて開発を進められるわけです。情報に間違いがないですし、時間の短縮にもなります。エンジニア一人一人のモチベーションも上がりますね。\n
新しい技術に対する日米の温度差\n
\n
－日本以外で活用されている国はありますか。\n
\n
まつもと：やはりアメリカでの利用が非常に多いですね。新しい技術は分からないことも多いので失敗することもあり、利用にはリスクが伴います。そのリスクをどのようにとらえるか、というのは一つの文化だと思うのです。アメリカのIT産業ではベンチャー企業が多く、「とりあえずやってみよう！」みたいなことがありますね。(笑)\n
普通、新しいビジネスにあまり有名ではない技術を使う場合、「情報はどうやって手に入れるのか？」や「エンジニアをちゃんと雇えるのか？」といったことを思って躊躇するのが普通だと思います。ところがアメリカのベンチャー企業、特にシリコンバレー付近で起業した人たちの場合は新しい技術を採用する傾向がとても強いように感じます。日本と違って、失敗しても許される社会、何度でも起業できる社会、ということも背景にあるのかもしれませんが。\n
\n
－作るのが簡単、という点がベンチャー企業に多く採用された理由でしょうか。\n
　日本でも同様の理由で採用が進んだのですか。\n
\n
まつもと：新しくビジネスを始めるときは、途中まで作ってからビジネスを軌道修正することも多々あります。今あるソフトウェアを改修して現在のレベルに到達するまでやり直すのに3週間かかるとなったら、「じゃあ改修しないでそのままでいこうか」という結論を出す場合もあると思うのです。\n
一方、15分で改修が済むのであれば、「じゃあやり直してみるか」という気になるわけですよね。 15分か3週間か、というのは時間的なものだけではなく、ソフトウェアそのものの質的な差を生んでしまう場合もあります。改修に時間がかからなければ、「ここをもう少し直してみよう」といった前向きな発想も生まれるので、その結果、より質の高いサービスが完成する可能性が高くなります。\n
日本はアメリカに比べてベンチャー企業が非常に少ないという違いがあるので、Rubyの利用状況について一概に比較はできません。日本企業では一般的に、プロジェクトに新しい技術を採用して失敗した場合、責任は何処が取るかという話になってしまいます。そうなると誰も知らない技術に飛びつくのは難しくなりますね。\n
Rubyの活用状況を時系列で紹介すると、2004年にRuby on Railsが発表され、2005年から2006年にかけてアメリカ西海岸のベンチャー企業がRubyを採用し始めました。2006年後半から2007年にかけて成功事例が増えてくると、Rubyを採用する企業が増えてきました。そうすると採用リスクは下がってきます。\n
そして2007年になってようやく日本のビジネスでRubyを使おうという話が出てきました。アメリカとは2年近く遅れているのです。\n
\n
－日本は新しい技術に対して随分と保守的なのですね。今後ビジネス面での活用が\n
　ますます増えてくると、日米ともにRubyエンジニアが足りなくなるのではないですか。\n
\n
まつもと：そうですね。実際足りないと感じています。特にシリコンバレーだと優秀なエンジニアは本当に取り合いになっています。昨年Rubyカンファレンスがシリコンバレーで開かれたのですが、「アメリカって景気悪いんじゃなかったの？」と思うくらい採用活動が活発でした。その傾向がまだ続いているようです。最近Rubyを勉強しました、というエンジニアではなく、もうワンランク上の人だと年収が日本円で1千万円からという場合もあるようです。\n
日本でももっとエンジニアの待遇を改善していかないといけないと思います。3Kといわれてしまうエンジニアですが、Rubyを武器にその世界から脱出した人も中にはいるので。Rubyを知っていることで、もっとエンジニアに理解のある会社に転職できた、という例もあるようです。新しい技術にアンテナを張っていることによって、自分の待遇を改善できる、ということは日本でもあると思います。\n
	</item>
	<item>
エッジの立った個性が集まり、新しい何かが生まれる\n
\n
茂木　Rubyというプログラミング言語を、まつもとさんは独力で開発された。プログラムを組むより言語そのものに興味があったという話は前回お聞きしましたが、組織ではなく個人で活動をスタートさせたわけですよね。\n
\n
まつもと　はい。私のように個人ベースで言語をデザインする人は少なくありません。\n
\n
茂木　ただ、個人の活動が必ずしもうまくいくわけではないですし、Rubyのようにヒットするケースはまれでしょう。パラノイアというと大げさですが、何かにすごくこだわっている個人が物事を成功させるのだと思うんです。\n
その半面、こうした人にはどこかに弱い部分があることも珍しくないです。まつともさんはどうなのでしょう。\n
\n
まつもと　私は多分、他の人にはできないくらい長い間、プログラミングやプログラミング言語の開発を続けることができます。時間感覚がなくなって、気がついたら朝になっていたこともあります。\n
一面では長所なのかもしれませんが、ひとつのことだけを続けてしまうのは弱点でもありますね。特に家族には迷惑を掛けるので、たまに怒られます（笑）。あと、人とのコミュニケーションにはあまり自信がありません。都会の雑踏なども嫌いで、私が島根県に暮らしている理由のひとつでもあります。\n
\n
茂木　なるほど。もうひとつ思うのは、個人で成功するにせよ、協力者が必要だということです。そもそも、エッジが立つ個性ばかりが多くても、それだけでは社会システムが成り立たないですからね。\n
シリコンバレーなどに行って最近思うのは、確かにエッジの立つヤツは多いのだけど、彼らにはいろんな方面に友達がたくさんいるんです。\n
\n
まつもと　言語デザイナーばかりがいても、プログラミング言語は使われませんから（笑）。\n
\n
茂木　そうなんですよ。いろんな方向にエッジが立っている個が集まって、彼らが協力し合うから何かが生まれるのだと思います。そうだとすれば、それがないのが日本の弱さじゃないかな。まつもとさんはどう思いますか？\n
\n
まつもと　エッジの立った人がうまく活躍できていないということですか？\n
日本の企業の中で、エンジニアの地位はなぜ低い？\n
\n
茂木　日本で「個人としての活躍」を語る場合は、「大きな組織」対「個人」といった二項対立のようなイメージが多いと思うんです。\n
例えば、Appleでスティーブ・ジョブズとスティーブ・ウォズニアックが、互いの優れた能力を融合させて製品を開発するといった、飛び抜けた個性が協力し合うイメージはあまりない。\n
しかし、そもそも企業とは、従業員の個性を補い合いながら効率よく仕事を進めるために存在するのだから、対立関係にならなくてもいいはずです。なぜそこがうまくいかないのでしょう？\n
\n
まつもと　日本の企業では、組織が大きくなると「組織の論理」なるものが生まれてくると思います。するとその結果として、従業員を代替可能な部品のように扱いたがる。ここが先ほどの「日本の弱さ」に通じるのではないでしょうか。\n
一理あることは認めます。確かに、巨大な組織の効率から考えると、メンバーのひとりを信じ切って大きな仕事を任せてしまうと、仮にその人が怪我や病気になった場合のリスクが高くなります。だから個人に依存できないと考えるのでしょう。\n
ですが、そんな考え方で個人の能力を生かし切れないのは、本当にもったいないと思います。\n
\n
茂木　日本の企業に関して言えば、文系職ではなくエンジニアであっても、ある程度の年齢になると「下の者の面倒を見てよ」とマネジメントを任せるようになる。仮に現場ではかなり優秀なプログラマで、マネジメントに全く向いていない人であっても。\n
\n
まつもと　私もマネジメントは苦手です（笑）。そもそも日本のソフトウェアエンジニアには技術職としてのゴールがなくて、30歳、40歳になると「お前、いつまでもエンジニアなんかしていないで、管理職になれよ」などと言われます。「エンジニアなんか」と下に見ているわけです。\n
つまり、技術職は代替可能な部品であり、管理職は彼らよりも社会的な地位が高いという認識です。すると上司は部品に対して、「この仕事をいつまでに片付けておけ」という発想で命令を出し、エンジニアの創造性を生かそうとは思わない。\n
\n
茂木　エンジニアは下でマネジメント職は上という意識は、IT大国になったアメリカでも、最初はそうだったんじゃないかな。徐々にクレイジーなプログラマやハッカーと呼ばれる人たちが出てきて、その仕事が高く評価されたり、あるいは億万長者になったりして、地位を上げていったように思います。\n
\n
まつもと　そういう意味では、海外のトップレベルのクレイジーな人たちがRubyを使ってくれているのは、私の誇りですね。\n
\n
日本のエンジニアは優秀、個人の魅力をもっと出すべき\n
\n
まつもと　ただ、日本も少しずつ変わってきています。今では個人のオピニオンをブログやTwitterで発信できますし、会社の仕事でなくても、オープンソースコミュニティを通して社会に貢献できるようになった。\n
企業という組織に依存することなく個人として踏み出せるのが、インターネット社会の大きな特徴だと思います。\n
\n
茂木　そういう場だったら、空振りしてもいいと思って、フルスイングができるのかもしれないですね。学生の勉強なんかもそうだと思うのですが、受験のための詰め込み教育ではモチベーションが上がらないもの。だって、面白くないんだから。でも、「Ruby開発プロジェクト」という勉強だったら、好きな人はとことんやる。\n
\n
まつもと　私もやっていたかも（笑）。\n
\n
茂木　アメリカの学生は日本が学生の3倍勉強すると聞くけれど、こうしたプロジェクト型の勉強が多いからだと思います。テストのための勉強じゃない。\n
そのためか、アメリカのソフトウェアエンジニアは個性的かつ優秀な人が多く、日本のエンジニアは創造力を発揮していないように思われがちだと思うのですが、まつもとさんから見てどうですか？\n
\n
まつもと　日本のエンジニアは、一人ひとりの能力は高いものがあると思っています。\n
\n
茂木　そうであるならば、彼らの能力が十分に発揮できていないと思うのはなぜでしょう。\n
まつもと　理由のひとつは、先の「組織の論理」にとらわれて、その中でしか動いていないこと。あるいは動けないこと。もうひとつは、特に日本発のプロダクトを海外に出すケースにおいて、組織が個人の力を使いきれてないからでしょう。\n
エンジニア個人の能力は高いと思います。私はたまに海外に行って、Rubyが好きだというエンジニアにカンファレンスなどで、アメリカのエンジニアたちと話し合うことがあります。すると、日本のエンジニアのほうが能力が高いのでは、と感じることが多々あるのです。\n
\n
茂木　ちょっと話は違いますが、スタンフォードやMITでの授業を見ると、教える教授の授業がつまらなかったりするんですよ（笑）。僕の友達の日本の教授のほうが、授業は面白いし、内容も有意義だったりします。日本人の能力って決して低くないですよね。\n
\n
まつもと　私の場合はRuby関連に限定されますが、全くそう思います。日本人は没個性で、集団となったら能力を発揮するように思われていますが、実は集団としても個人の能力を活用しきれてないのかもしれない。\n
それでも、日本人集団の力が評価されているのですから、個人個人がもっと外に能力を出していけば、日本もかなり変わると思います。\n
言い出しっぺに必要なのは、周りの人を巻き込む力\n
\n
茂木　日本のエンジニアがその能力において外国人に引けを取らないとしても、皆がプログラミング言語を開発できるわけではない。というより、やりたいことはそれぞれです。エンジニアが仕事を、あるいは技術を楽しむためには、何をしたらよいと思いますか？\n
\n
まつもと　エンジニアには「これが好き」を持っている人は多いんです。ですから、やりたいことはわかっているでしょう。だとしたら、小さくてもいいから好きなことができるプロジェクトをつくって、進めて、「こんなことをやり遂げました！」と周囲にアピールする。会社でも、個人の活動でも構いません。\n
そうなれば、「これいいじゃん」みたいな声も出てきます。そんな実績を積んだ人たちが集まれば、その交わりの中で個人のパワーが増幅されます。個人のパワーが高まれば、コミュニティのパワーも膨らみます。\n
私だってRubyという言語をつくったことで評価されていますが、ここまで来られたのはコミュニティの力であって、個人でできることは限られています。\n
\n
茂木　何かを最初に始めた人は評価されるべきでしょうけど、人とつながることで仕事でも何でも前に進んでいくのは確かですね。\n
\n
まつもと　はい。ですから、言い出しっぺに必要なのは、どうやって周りの人を巻き込んでいくか。私はたまたまそれがプログラミング言語でしたが、人の好き好きですから、対象は何でもありだと思います。\n
ただ、私は本当に人づきあいが苦手ですし、コミュニケーション能力も乏しいのですが……。\n
\n
茂木　つまり、そんな人でも好きなことであれば、Rubyのコミュニティをつくることができたわけですね。\n
それでも、メタ認知を使ってのプログラミング言語開発の能力、プログラミング自体の開発能力と、まつもとさんの場合はかなり特殊でしょうね。人にはさまざまな幾多の能力があるわけですから、それらを組織の中で育み、伸ばしていける企業が、日本に増えてほしいです。\n
\n
まつもと　社会全体としてそうあってほしいですが、現実問題としては「裏口」を広げていくしかないのかと思っています。私が会社勤めを続けながら、Rubyを開発してきたように。\n
\n
茂木　なるほど。まずは「裏口」で、アンダー・ザ・テーブルから個人の力を出していく。コミュニティ活動もその一部になるのかもしれませんね。今日はどうもありがとうございました。\n
\n
まつもと　こちらこそ、ありがとうございました。\n
	</item>
	<item>
高校時代、既に自分のデザインした言語でのプログラムを書いていた\n
\n
　コンピュータとの最初の出合いは、小学校６年生のとき。父親が買ってきたポケットコンピュータ「L-Kit16」でした。といっても、コンピュータなんて認識はなくて、ダンプリストを打ち込んで、LEDが光るのを見て喜ぶ程度でしたけど。それから中学３年で、また父親が今度はシャープのポケットコンピュータ「PC-1210」を買ってきたんですよね。ここで初めてプログラミングというものを知るんです。機械にこう命令すると、こう動くんだ、と。BASICを理解して、サンプルを打ち込んだりして。面白かった。父親は、建材関係の会社に勤める普通のサラリーマンでした。実はポケットコンピュータは、会社の事務計算に役立てようとしてたようなんですが、僕が取り上げてオモチャにしてしまった（笑）。\n
　子どものころといえば、とにかく本をよく読んでいました。というのも、家の目の前が本屋さんだったから。ずっと本屋にいたので、あるとき友だちが遊びに来て家に入れようとすると、「お前の家はあっちじゃないのか」と本屋を指さされたりして（笑）。SFでもマンガでも何でも読みました。活字が好きだったんですよね。それこそ、百科事典も頭から全部読んだし、薬の説明書も読んでた。\n
　高校に入ってからは、コンピュータへの関心が高まって、コンピュータ雑誌にのめり込みました。自分が考えたとおりにコンピュータが動くのが面白かったんです。既に、持っていたコンピュータの性能に不満を持っていました。特にプログラミング言語に興味があって。どうも、アセンブラは好きになれないなぁ、とか。BASICでプログラミング言語は作る気になれない、とか（笑）。それで、自分でプログラミング言語を作ろうと思い始めていたんです。実際、自分のデザインした言語でノートにプログラムを書いていました。残念ながら、そのノートは残ってないんですけど。ついでにいうと、名前も決めてたんです。「Ruby」じゃないです。まったく違う名前。あまりに恥ずかしい名前だから、絶対に明かさないです、これは（笑）。\n
\n
図書館と研究室に通いつめていた大学時代	\n
\n
　大学は情報系に進んだんですが、ようやくちゃんとしたプログラム環境に出合えたのがうれしかった。それまでは触れてなかったUNIXや、書籍の中でしか見たことがなかったソフトウェアや言語などに直接触れることができて。高校時代に読んだ本の著者が研究室の先生だったというのも、うれしい出来事でした。プログラミング言語の研究室です。でも研究室のテーマは言語処理系の実装方法についてだったので、私一人先生の言うことを聞かないで、自分で言語をデザインしたりしていましたが(笑)。\n
　バブルの時代でしたけど、遊んだりしていた記憶はないですね。ずっと図書館にいて、やっぱりいろんな本を読んでいました。遊びに行くとすれば、映画館か、それともやっぱり本屋か（笑）。運動は得意じゃないし、みんなで何かやることにも関心がなかった。本は子どものころから本当にずっと読み続けていましたね。最近になって、ネットのおかげで昔ほど読まなくなりましたけど。でも、いろんな分野の本を読んできたことは、自分に大きな意味があったと思う。\n
　あとは、研究室によくこもっていましたね。一晩中、研究室でコンピュータをいじって過ごして朝、家に帰ってシャワーを浴びて、また研究室に来たりとか（笑）。80年代後半でしたけど、既に研究室ではインターネットが走っていたので、ネットニュースとか掲示板とかも見てましたね。面白いなぁと思いました。世の中には頭のいい人がいるんだな、と。\n
　当時はまだコンピュータは黎明期。実は父親は、情報系の学校に行くのは反対していました。コンピュータやプログラムは趣味にしとけ、と。メカなどの技術者にしたかったみたいですね。でも、僕はとにかくコンピュータが好きでしたから。先のことなんて全然考えていませんでした。\n
	\n
不況で時間ができて、「Ruby」開発が始まった\n
\n
　1990年に卒業して、ソフトハウスに入りました。決めていたのは、東京では働かないということ。田舎育ちで人が多いのは嫌いだったし、通勤に１時間も２時間もかけるなんて考えられなかった。だから、地方のソフトハウスがよかったんですが、そうなると、選択肢はかなり限られて。でも、浜松で働ける会社と出合って、そこを選ぶんです。\n
　仕事は社内OAシステムの開発です。当時まだテキストしか送れなかった電子メールを、添付ファイルを送れるようにプロトコルからツールを開発したり。面白かったですね。こういうものを作る、というテーマは決まっていましたけど、自由に作らせてもらえたので。３分の２の時間をライブラリに充てたりとか（笑）。フリーソフトも使っていました。好きにやって、遅くまで残って仕事をして。やっぱり先のことは何も考えてなかったです（笑）。一生、プログラマでスキルを上げていくことが夢でしたね。おじいさんになっても、開発していよう、と。\n
　ところが、数年すると、バブル崩壊の影響が出始めて。社内システムも、仕事が減って忙しくなくなってしまった。でも、マシンはあるわけですから、できることをやろうと思って。それで「Ruby」の開発を始めたんです。あったらいいなぁと思えるものを、時間があったんで作り始めてみた。それだけです。会社でやっていましたから、同僚には話していました。いろいろ応援してくれましたね。\n
　開発を始めて１年くらいで転職するんですが、これは会社の経営が厳しくなってきたから。仕事内容には不満はなかったし、環境も友達にも恵まれてたんですが、当時既に結婚していて家庭もありましたから、会社がつぶれてしまっては困る。一方で、自分を高く売れるうちに売っておこうという気持ちもありました。当時はオブジェクト指向技術者は少なかったから。友人に紹介されたエージェントを通して活動しました。ここでもやっぱり条件は、東京勤務じゃないこと。それで名古屋のCADベンダーと出合うことができた。\n
　家にはコンピュータはありませんでしたから、この職場でも「Ruby」は会社で開発しています。でも、もちろんそんな業務命令は出ていない。ただ、本来の仕事でのアウトプットはきちんとしていました。だんだんと気持ちは「Ruby」のほうが大きくなっていきましたが。今だから言いますが、ときには、「Ruby」の開発の時間を確保するために、ちょっと本業の開発時間を長めに見積もったりさせてもらったことはあったなぁ（笑）。\n
　直属の上司には「Ruby」のことは言っていませんでしたが、会社のシステム管理者には話していました。転職して１年ほどで「Ruby」を公開するんですが、そのとき会社のWebページに間借りさせてもらっていましたから。好きでやってるんだ、それならいいよ、と。今から考えると、のどかな、いい時代でしたね。\n
\n
心がけてきたのは、自分が欲しいものを作ること\n
\n
「Ruby」の開発で世界に知られて、なんて言われますが、ここ数年のことですからね。別に有名になろうと思ったわけでもないし、ずっと好きでやってきただけ。言ってみれば、趣味みたいなものです。釣りやスノボを趣味にしている人と同じで、見返りは最初から期待してない。どんなにハマっても、それで有名になろうとか、儲けようとか考えないでしょう。ソフトウェアだとビジネスが成立しているから期待しちゃう人が多いのかな。僕の場合、幸いだったのは、プログラム言語というのは、もともとお金にならないものだということが最初からわかっていました（笑）。無料が当たり前ですから。だから、誘惑されることもなく（笑）。その意味では、今は本当にありがたい立場です。「Ruby」の開発だけで給料がもらえているわけですから。\n
　でも、気がついたらこうなっていたんです。局所最適化というか、そのときどきに一番いい方向を選んできたら、今があったというだけ。これまでも長い先は考えなかったし、今もそうですね。10年先なんて考えてない。先のことは、わかんないですから。\n
　ただ、開発にあたって大事にしてきたことはあります。それは、自分が欲しいものを作ること。僕は短気で（笑）。だから、自分がイライラしないものを作りたかった。シンプルで、わかりやすいもの。誰に気に入ってもらおうとか、使ってもらおうとか、そういうものではない。自分が使いたいもの。誰かのために役立つという利他的精神は、ないわけではないけれど、自分ではあまり意識してないですね。それよりも、圧倒的に自分がイライラしなくてすむという利己的精神のほうが強い（笑）。\n
　僕のソフトを気に入ってくれた人は、僕と感性が近い人でしょうね。僕は本気で自分が我慢しなくてすむようなものに取り組んできましたから。感性の近い人には、うれしいものになっていると思いますよ（笑）。\n
\n
自分がやりたくないことをやるのは、大変なこと\n
\n
　もちろん、一生懸命作ってきました。それこそ脳みそから汁が出るくらい考え抜いて（笑）。ただ、そういう設計上の難関というのは、なきゃないでつまんないんですよね。むしろ、難しいから燃える。難しいから面白さがある。そういう感覚は、大事にしています。でも、大変だと思ったことはないです。人間にとって一番大変なのは、やりたくないことをイヤイヤやらされることです。むしろ、僕は「Ruby」でいかにそれを減らそうかと奮闘しているわけだから。労力も時間もかかっているけど、ちっとも大変じゃない。むしろ、好きでやってるわけですから楽しい。\n
　では、どうして「Ruby」がうまくいったのかと聞かれたら、長い時間、本気でやり続けてきたから、ということだと思うんです。そもそも「Ruby」はそれほど革新的なものでもない。世の中のどこにもないものを作った、新しいジャンルを生んだ、とかではないんです。似たようなものはいくらでもあります。自分が欲しいものを、あきらめずに開発し続けたことで、自分の趣味に合うと言ってくれる人が出てきてくれた。そういう人たちが作ったツールを気に入ってくれた人が現れてくれた。「Ruby」が特別優れているから、というのではなく、ほんのちょっとの違いの積み重ねが今になっていると思うんです。決して、どこにもない、今までになかったものを作ったわけではないんですよね。\n
　大事なことは、ゴールが明確なことです。はっきりとしたゴールを決める。僕の場合は、自分がイラつかない、がゴールです。でも、世の中では漠然とした目標が立てられることが多々ある。例えば、「何か新しいものを」とか「何かいいものを」とか。こういうぼんやりしたゴールでは、アウトプットが出たときに評価ができません。\n
　とりわけ技術では、新しいもの、というのがキーワードとしてよく取りざたされますが、僕にはよくわからないですね。「新しいものかどうか」という評価軸そのものが僕にはないからです。新しいか新しくないかが問題なのではなく、自分にとって便利なものが自分の手の中にあることかどうかこそが重要だと思うから。今、自分が便利かどうか、快適かどうかです。だからエンジニアとしての僕は、新しいかどうかは気にしませんし、なりません。今、僕の目の前の問題を解決できるかどうかこそが問題だと思うんです。\n
\n
成功しているのは、いびつさを恐れなかった人たち\n
\n
　エンジニアに伝えたいのは、いびつさを恐れてはいけないということですね。日本の学校教育は、人を平準化しようとしてきた。でも、僕がこれまで会ってきた成功者たちは、その多くがある種、いびつな人たちだったんです。何か問題があったとき、それを解決する能力というのは、平準化した低い山のような能力ではない。むしろ、あるところは極端に低くても、あるところが突出して高い、いびつな能力を持った人です。そういう人が、問題解決を行える人なんです。必要なのは、能力があるかではなく、問題が解決できることです。そのための能力ですから。\n
　ここ20年ほど、ITの世界は激変してきたとよく言われます。しかし、一見そう見えても、実はシステムを巡る環境というのは、あまり変わっていないというのが、僕の印象です。たしかに新しい技術は、出てきたり、消えたりしてきました。でも、実は基本は変わっていないんです。UNIXは20年変わっていない。HTTPは十数年変わっていない。テキストプロトコルに至っては、30年以上変わっていない。ベースは全然変わっていない。\n
　その基本を押さえないで、表層のアプリケーション技術だけに向かっていたらどうなるか。５年たったら、使えなくなります。たしかに表層の技術をトレンドとして追うことも大事。でも、それ以上に重要なのは、しっかり基本、基礎を理解しておくこと。そうでないと、時代に振り回され、得た知識を無駄にするだけです。\n
　逆にいえば、基礎を押さえ、自分が向かいたい方向さえ、きちんと定まっていれば、どんなトレンドがきても怖くないし、心配する必要はないということ。新しい技術は、自分が向かう方向に便利に使えるツールになるわけです。その意味では、自分がどこを向いているかこそが何より重要だと僕は思いますね。どこに所属しているか、とか、どこにいるかとか、そういうことではない。自分がどうしたいか、こそが問われる。そういう時代だと思います。\n
	</item>
	<item>
既存のプログラミング言語も誰かが作ったもの。自分が作ってみたっていい\n
\n
初めてプログラミングをしたのは中学3年生のときです。といっても、BASICというプログラミング言語で書かれたサンプルデータを打ち込んで簡単なゲームを作る程度なんですけどね。自分が命令をすると機械が動くというのが新鮮で。ラジコンなどはいちいち操作しないと動かないけど、コンピュータは一度教えれば、ある程度自律的に動く。インテリジェンス（知性）を感じてすごくかわいいなと。BASICを勉強し、プログラミングに夢中になりました。ペットをしつけるような感覚だったんです。\n
高校生になると以前よりはいいパソコンを使うようになりましたが、だんだん物足りなくなりましてね。プログラミング言語についても、BASICでは自分が意図したことを表現しにくいと感じていました。そこで、Pascalというプログラミング言語の入門書を読んでみると、BASICでは表現しづらかったことを解決できそうだと。さらに知識が増えてくると、世の中にはたくさんのプログラミング言語が存在し、それぞれ特色があるということもわかりました。プログラミング言語に興味を持ったのはそのときからです。コンピュータにやらせたいことをどの言語で表現するかによって、人が思考しやすくなったり、プログラミングが楽になる。プログラミング言語というものが人をハッピーにできることが面白いなあと思ったんです。\n
自分でプログラミング言語を作れたらいいなという気持ちはこのころからありました。「こんな風に表現できる言語があるといいな」とノートにプログラミング言語を書いたりして。BASICやPascalといった既存の言語も誰かが作ったもの。しかも、どちらも完璧というわけではなさそうでしたから、自分が作ってみたっていいんじゃないかなと思ったんです。とはいえ、深い知識も、自分で考えた言語が動くかどうかを試せるパソコンやソフトウェアもなかったので、実体は伴っていなかったんですけどね。\n
高校時代、周囲にコンピュータをやっている友だちはいませんでした。大学は情報系に進んだので、「コンピュータに興味がある人もやっぱりいるんだな」と。ところが、よくよく話してみると、「ゲームを作りたい」などコンピュータで何かをしたいという人はいても、その道具となるプログラミング言語を作ろうという人はやっぱりいなくて。自分がそこまで少数派だとは認識していませんでした（笑）。4年生になって入った研究室でも、テーマは「既存の言語の最適化をいかに行うか」といった内容なのに、私だけ卒論で新しい言語をデザインしました。「Ruby」以前に実際に動く言語を作ったのはこのときだけです。実用できるようなシロモノではありませんでしたが。\n
卒業後は浜松にあるソフトウェア会社に就職しました。情報システム系の仕事は東京に多かったけど、私は東京では働かないと決めていました。人ごみは堪え難いし、郊外からの通勤に往復5時間かかるような生活はイヤだなと。同期は200人ほどいましたが、情報系の大学を卒業したのは5、6人。経験者は重宝されてみんなより早く現場に配属され、社内OAシステムの開発を担当しました。作るものは決まっていましたが、ゴールさえ達成すれば自由にやらせてもらえたので、すごく面白かったです。\n
ところが、バブル崩壊の影響で入社3年目あたりから仕事が激減しまして。暇を持て余して、何か好きなものを作ろうと作り始めたのがプログラミング言語Rubyなんです。大らかな時代でしたから、会社でやっていてもみんな応援してくれました。その後、会社の経営が厳しくなってきて名古屋の自動車部品ソフト設計会社に転職しましたが、Rubyの開発は続け、95年にフリーソフトとして公開しました。公開2週間でメーリングリストの登録が約200件あったのですが、プログラミング言語に興味がある人がそんなにいるとは思わなかったので意外でした。\n
その後、勤務していた部署が東京に移ることになり、転勤拒否したら置いていかれまして（笑）。どうしようかなあというときに知人が島根県で新しい会社を立ち上げるという話を聞いて、今の会社に転職しました。Linux（フィンランドのプログラマーが1991年に開発した無償配布のOS）やフリーソフトウェアを中心にシステム開発をする会社で、全国でもあまり例がないので面白そうだと思って。Rubyをやるという話ではなかったのですが、入社後Rubyの評判が高まって、気がついたらRuby関連の仕事だけでお給料をいただけるようになっていました。\n
\n
モチベーションというのは具体的でないと力が出ない\n
\n
公開後15年以上たった現在、「Ruby」は世界中の人たちが利用してくれています。何に使われているのかを私が知るよしはありませんが、「ツイッター」に使われていると聞いたときはさすがにびっくりしました。公開時には予想していなかったことばかりです。今でこそ「Ruby」でごはんを食べるというありがたいことになっていますが、もともとは好きで作っただけ。有名になろうとか、儲けたいというような「たくらみ」もなかった。プログラミング言語というのは無料が当たり前の世界で、お金にならないことは最初からわかっていましたから。\n
ただ、図らずもこうなったのがなぜか考えてみると、私はプログラミング言語が大好きで、この領域に関しては日本でも上から数えた方が早いくらい時間を使ってる。いろいろ知っている方だとは思うんですよ。そのことが今につながってきた。だから、やりたいことをやるというのは大事ですよね。やりたいことなら、壁にぶつかっても乗り越えて長く続けられる。その結果がほかの人との差別化につながるんじゃないかと思うんです。\n
特にソフトウェアというのは形のないものですから、作り手のモチベーションがすべてを左右します。そのモチベーションも「有名になりたい」とか「お金持ちになりたい」ではない方がいいでしょうね。その一番の理由は、曖昧すぎるから。モチベーションというのは具体的でないと力が出ないんです。そういう意味では「何か新しいことをしたい」というのも志は素晴らしいですけど、同じかもしれませんね。私の場合、目指しているのは自分が欲しいものを作ること。「Ruby」なら、シンプルでわかりやすく、ストレスなく使えるプログラミング言語を作りたかった。自分が欲しいものですから、相当具体的ですよね（笑）。\n
ところで、「Ruby」はオブジェクト指向という考え方に基づいて作られています。オブジェクト指向というのは、プログラミングをするうえで人間には複雑過ぎる手続きを、「オブジェクト」と呼ばれるまとまりで表現してわかりやすくしようという考え方です。私は高校時代にこの考え方を初めて知り、秘かに熱くなりましてね。「いいよ、これ。未来のプログラミングのあるべき道だ」なんて。\n
そこで「Ruby」もオブジェクト指向で作ったのですが、「Ruby」を世に出した当時、オブジェクト指向はそれほど評価されていませんでした。だけど、オブジェクト指向は現在のIT業界では当たり前になっています。「Ruby」でオブジェクト指向に触れ、「プログラミングが楽になった」と言ってくれる人もいて、やはりうれしいなと思います。「Ruby」は私が欲しいものを具現化したものですが、同時に人もハッピーにできているとしたら、プログラマ冥利に尽きます。\n
	</item>
	<item>
どこから生まれる？100倍というプログラマの開発効率\n
\n
茂木　初めまして。茂木健一郎です。\n
\n
まつもと　初めまして。まつもとゆきひろです。妻が茂木さんのファンなんです（笑）。\n
\n
茂木　ありがとうございます（笑）。まつもとさんはプログラマであり、Rubyの開発者ですよね。\n
僕はプログラミングはBASIC、FORTLAN、C、C++くらいしかやっていなくて、それ以降の言語はほとんど触っていないのだけど、ハッカーのような友達に聞くと、プログラマの開発効率は人によって10倍、あるいは100倍の差が出るとか。それは本当ですか？\n
\n
まつもと　そう思います。\n
\n
茂木　すると、まつもとさんのプログラミング能力は一般のエンジニアに比べて、100倍高い？\n
\n
まつもと　プログラミングには、閾値というものがあるんです。例えば、経験の浅いプログラマには開発の全貌が見えないので、どうやっていいかわからない。手も足も出ないことだってあります。\n
それが、見える範囲が広い別のプログラマなら、「ああ、できるよ」と簡単に達成できてしまう。その閾値を傍から見ると10倍、100倍という差になるのでしょう。\n
知識があったり、経験が豊かだったり、勘が鋭かったりするプログラマは、その閾を乗り越えられるわけです。\n
\n
茂木　われわれ脳科学者の立場からすると、例えばモーツアルトのような天才を対象としたときに、「この人は特別だから」という仮説で片づけてしまうのは短絡的だと思うんです。僕は、必要条件と十分条件のどのような要素が組み合わさってモーツアルトになったのかに興味があります。\n
マルコム・グラッドウェルの書いた『アウトライアーズ』[日本語版『天才！成功する人々の法則』（講談社：勝間和代訳）]という本には、「1万時間の法則」（成功は1万時間の努力の積み重ねである）が出てきます。著名な成功者は特別な人だったのではなく努力家であり、いわばその閾値が1万時間だったという説ですが、その辺りをまつもとさんに伺いたいですね。\n
Rubyが開発できたのは、「メタ認知」能力が高いから？\n
\n
茂木　そもそも、Rubyの開発前は、どのくらいのプログラミングに習熟していたのですか？\n
\n
まつもと　中学校3年生で初めてプログラミング言語に触れて、最初はBASICを使っていました。次はPascalでしたが、当時はコンパイラが高くて、地方の貧乏学生には手が出せなかった（笑）。そこで、本を読んで学んだのですが、BASICとは設計発想が随分違うと気づきました。\n
興味を持って調べたら、もっともっと違う言語があるとわかった。世の中にはさまざまなプログラミング言語があり、それぞれが異なる発想でデザインされていることを知って、これは面白いと思ったんです。\n
\n
茂木　Pascalの次は何を学んだのですか？\n
\n
まつもと　BASIC以降は「本で学んだ」わけですが、次がLisp、Smalltalk、Adaと続いて、ほかにはC、LOGO、Prolog……\n
\n
茂木　2桁はいっているわけですね。やっぱり普通じゃない（笑）。僕も高校のときはBASICで重力シミュレーションみたいなプログラムを書いていましたし、プログラミング言語を使って何かを表現しようとする人は多いと思うけど、言語そのものに興味を持つ人は少ない気がします。\n
まつもと　何をつくるのかはどうでもよくて、言語自体にハマったんですよね。小学校6年生のときに父がワンボードマイコンを買ってきて、マシン語でしか動かないので数字を打ち込んだりしていましたが、プログラムには夢中にならなかった。\n
\n
茂木　『アウトライアーズ』のように、まつもとさんにはプログラミングに1万時間を使って成功しているという認識はないのですね？\n
\n
まつもと　Rubyはたまたま世界に広がりましたけど、それまでの私は、人より少しできるくらいのプログラマだと自覚していて、周りの人がほめてくれるとこそばゆく感じるくらいのエンジニアでした。\n
また、私はRubyを開発しましたが、実装という面でソフトウェアの品質をよりよくするための提案をしてくださる方々はコミュニティにいて、この点では彼らのほうが優秀ですね。\n
\n
茂木　われわれの言葉で「メタ認知」（自分の考えや行動を客観的に認識すること）と呼ぶのですが、自分のつくったシステムを外から評価する能力が、まつもとさんは高いのかもしれませんね。\n
\n
まつもと　確かに言語をデザインする能力は、プログラムを開発する能力とは違うと思います。\n
\n
数学が嫌いな「言語デザイナーの脳」に興味あり\n
\n
茂木　では、まつもとさんのどんな能力が言語のデザインに役立ったのでしょう。そうですね……学校の教科では何が得意でしたか？\n
\n
まつもと　得意な学科ですか……数学がダメで、物凄く悪かったです（笑）。中学も高校も成績が悪くて、高校3年生で「1」を取りました（笑）。微分・積分とかわからなくて、何ていうのか、興味が持てないんですよ。\n
\n
茂木　興味が持てないことはやらない？\n
\n
まつもと　やれない、ですね。\n
\n
茂木　そんなことにはリソースが割けない。成績が悪くても気にしない。\n
\n
まつもと　いえ、気にはしますよ（笑）。受験するつもりがあったので、さすがに「1」には衝撃を受けました。しかも、10段階評価の1でしたから（笑）。先生にはしょっちゅう怒られていましたし、これでも努力はしたのですが。\n
\n
茂木　本当ですか？\n
\n
まつもと　もちろんです。でも、自分なりに勉強して、試験の前には数学がわからないという友達に教えても、試験の結果はそいつのほうが上なんですよ。もう、何がなんだかわからない（笑）。\n
多分、モチベーションが維持できないんです。計算なら電卓にさせればいい、解法だったら教科書を読めばいいと思ってしまう。\n
\n
茂木　でも、大学は理系に進んだんですよね。失礼ですけど、どちらの大学ですか？　そして、どうやって入ったんですか？（笑）\n
\n
まつもと　大学は筑波大学です。私は共通一次世代なので、他の科目で点数をカバーしたのと、英語が2次試験にあったんですよ。私は英語と国語が得意科目だったんです。\n
\n
茂木　やっぱり「言語」が得意なんだ（笑）。僕はそもそも理系と文系に分けることに疑問を持っているのですが、まつもとさんはどこかで、「プログラミングには数学とは別の能力が必要とされる」とおっしゃっていますよね。数学に対して劣等感はない？\n
\n
まつもと　いえ、いまだにありますよ（笑）。\n
\n
茂木　ただ、脳では得意なことと不得意なことは表裏一体で、トレードオフの関係にあります。ですから、数学が得意だとプログラミングの能力が発達しない可能性もあるわけです。\n
プログラミングの能力とは違うのでしょうが、脳科学者としては「言語デザイナーの脳」に大変興味があります。こちらは数学が苦手、というより数学のテスト問題が嫌いと言うことに大きなヒントがあると思いますね。\n
\n
Rubyが「ヒット曲」になったのはタイミングも一因\n
\n
茂木　プログラミング言語は、年間でどのくらいリリースされるものですか？\n
\n
まつもと　趣味レベルでつくれるので、具体的な数はちょっと……。\n
\n
茂木　ただ、言ってみればRubyはヒット曲なわけですよね。年間で何千何万と楽曲は生まれるけど、ヒット\n
する曲は限られている。\n
\n
まつもと　ヒット曲レベルだと、せいぜい世界で1年に1曲くらいでしょうね。\n
\n
茂木　そんなにヒットするプログラミング言語を開発する能力はかなり特殊だと思います。ひょっとしたら百万人にひとりかもしれません。\n
進化生物学で「ホープフル・モンスター」と言うのですけど、多種多様な種が生まれて、それぞれが勝ち残ろうと、いつか主流になろうと努力しています。プログラミング言語における生き残りの差とは何でしょう。やっぱりクオリティ？\n
\n
まつもと　クオリティだとは思いますが、それは技術レベルという意味だけでなく、ユーザーを惹きつける魅力があるかどうかでしょうね。使ってもらってなんぼですから、プログラマの方々に、その言語を使う熱意を持ってもらえることが大切です。\n
熱意があれば、仕事だけでなく趣味のプログラミングにも使うでしょうし、もっと知りたいとコミュニティ活動へも広がっていきます。すると、皆で集まってイベントや勉強会を開くといった動きも出てきて、未知の人への啓蒙活動にもなります。このようにして徐々にユーザーが広がっていくわけです。\n
\n
茂木　プログラミング言語にも流行があって、新しい言語がリリースされたら飛びつくアーリーアダプターがいると思うんですが、そうしたコミュニティが世界にはあるのですか？\n
\n
まつもと　プログラミング言語のアーリーアダプター・コミュニティはあまり聞かないですね。ただ、別の言語に移ろうかなと考えているプログラマがいて、そのときにうまく新しい言語が出てくれば移行するケースはありますね。\n
逆に言えば、新しい言語が出てくるのを待ち構えていて、リリースと同時にそこに移るといった、渡り鳥のような人は少ないと思います。\n
\n
茂木　つまり、ヒットするにはタイミングも必要だと。\n
\n
Perlの後継としてエンジニアに受け入れられたRuby\n
\n
まつもと　かなり大きい要素だと思います。オピニオンリーダーのような人がいて、タイミングが合って「Rubyに移行したよ」などと言えば、その方の意見は説得力があるので周囲に波及するなどもあります。\n
\n
茂木　Rubyのリリースが1995年だと思うのですが、会社でプログラマをしながら開発したのですよね？　完成までに何時間くらいかかったのですか？\n
\n
まつもと　20年近く前の2月に作り始めたのですが、皆さんに使ってもらうまでに2年少しかかりました。1日1～2時間ほどを続けて、合計で600～700時間でしょうか。\n
\n
茂木　1995年はタイミングとしてはよかった？\n
\n
まつもと　そう思います。ちょうどインターネットが出始めて、CGI（Common Gateway Interface）を作り始めるときにPerlがよく使われていたのですが、「もう少し別の言語がないかな」と探していた方がそれなりにいた時期だったんです。Perlの後継としてRubyを選ばれたプログラマは多かったと思います。\n
私もPerlよりもわかりやすい言語という考えで開発しましたし、Perlが好きだったので同じ宝石の名前にしようと「Ruby」と付けたんです（笑）。\n
\n
茂木　なるほど（笑）。当初からドキュメントは英語でリリースしたのですか？\n
\n
まつもと　いえ、最初は日本語だけでした。ただ、あるオープンソースのプログラミング言語をダウンロードしたらドキュメントやコメントが知らない言語、確かロシア語で、全く読めませんでした。\n
面白そうなことやっているにその内容がわからない。そんな思いを他の人にさせたくないと思い、Rubyのリリース後、2年くらいかけて英語のドキュメントを書きました。ここからRubyが広がりました。\n
\n
茂木　今、Rubyはどんな使われ方をしているのですか？\n
\n
まつもと　Webのサーバーサイドがいちばん多いと思います。例えば、クックパッドさん、食べログさん、TwitterのWebサービスの部分などにRubyが使われています。私はネットワーク応用通信研究所のフェローのほか、Rubyアソシエーションという団体の理事長も務めています。\n
\n
茂木　フェローっていいですよね、自分の好き勝手な仕事ができそうで。特にエンジニアの場合はそんな気がします。\n
\n
まつもと　確かに、当たっています（笑）。\n
	</item>
	<item>
私がプログラミングを始めたのは中学校３年生のときでした。父が買ってきたシャープのポケットコンピュータ（PC-1210）でBASICを使うようになったのです。わずか400ステップしか入力できない小さなコンピュータでしたが、それでも自分の命令したとおりに動作するポケコンを見ていると、自分にはなんでもできるようなそんな「万能感」を感じさせてくれました。\n
　それから四半世紀以上たちましたが、私がプログラミングから感じる「わくわく」は少しも減ることはありません。むしろ、どんどん増えているように感じます。長いプログラム経験を踏まえて、いま、感じるのは、\n
プログラミングは人生だ\n
ということです。プログラムには人生のあらゆる側面が詰め込まれています。文字どおり、人生そのものといってもいい過ぎではないでしょう。……うーん、やっぱり、いい過ぎかな。\n
\n
プログラミングはスポーツだ\n
\n
　皆さんの多くは若いときにスポーツに熱中されていたかもしれません。あるいはいまでもスポーツ好きかもしれませんね。スポーツは人生を豊かにしてくれます。少なくともそう聞いています。\n
　あいにく私は子供のときからさほどスポーツが得意ではなかったのですが、それでもスポーツを楽しむ人の気持ちは分かります。そして、プログラミングもスポーツと共通する要素をたくさん持っています。\n
　プログラミングがスポーツだなどというと、懸け離れた印象を持ち、あきれる人もいらっしゃるかもしれません。しかし、例えば西洋ではチェスをスポーツに分類する人もいるくらいで、頭脳を中心とした活動をスポーツと見なすことは決して的外れとはいえません。\n
　プログラミングとスポーツの共通点としてまず考えられるものは、練習と反復による技術の向上です。優れたプログラマになるためには、知識と経験値が重要です。それはまさにスポーツ選手が練習によって自己研鑽（けんさん）するのと同じ構図です。しかも、ときには苦しい練習を彼らは喜んで行うのです。\n
　また、美しさやスピードの追求もスポーツに似ています。優れたプログラマは、自己の「作品」であるプログラムの「美しさ」にこだわります。それはある種のスポーツの「芸術点」の追求に似ています。また、パフォーマンスチューニングするときの、測定とボトルネックの探求、改善は、水泳や陸上の選手と類似の精神構造でしょう。\n
\n
プログラミングは趣味だ\n
\n
　例えば日本の野球人口に対して、プロ野球の選手になる人はほんのわずかです。多くの人は趣味として野球に接するわけです。同様に趣味としてプログラミングにかかわる人も大勢います。世の中の多くのオープンソースソフトウェアはもともとそのようにして誕生したものがほとんどです。また、プログラムのバグを取る活動は、パズルを解くのと同質の喜びがあります。\n
　一方、プロスポーツ選手とはっきり異なるのは、そんなに好きでもないのに仕事としてプログラミングを選択する人が相当多いことでしょう。スポーツ選手よりもプログラマの方が世の中にたくさんいるからかもしれませんが、個人的にはそれは不幸なことだと思います。\n
\n
プログラミングはコミュニケーションだ\n
\n
　コンピュータの前に向かうことの多いプログラミングという作業ですが、その多くの部分は意外に人間的です。というのも、いまだにプログラミングそのものを行うコンピュータが登場していないことからも、プログラミングは人間的な活動です。人間にしかできないといってもよいでしょう。\n
　それだけでなく、コンピュータを思いどおりに動かすためにプログラムを作るわけですが、プログラムはあくまでも人間が使うものなので、ヒトが何を求めているか、どのように感じるか、ということが非常に重要な要素になるからです。プログラミングには何が求められているのかを引き出すコミュニケーション力が必要です。また、複数人でプログラムを行うときには、開発メンバ間の意思疎通にもコミュニケーション能力は不可欠です。\n
\n
プログラミングは創造だ\n
\n
　私がプログラミングを好きで、何年たっても飽きない理由を考えてみると、その最大の理由はプログラミングがクリエイティブな作業であることではないかと思います。\n
　ただ道具としてのコンピュータさえあれば、あとは全く何もないところから、一つの世界をつくり出すことができます。プログラミングの世界には重力や因果など、現実世界に付き物の制約がほとんどありません。このような自由な創造活動は、他に類を見ないでしょう。自分の思うままに世界をつくり出すことができる。それこそがプログラミングの最大の魅力です。\n
\n
一生プログラミング\n
\n
　プログラミングは、ほかの多くの活動に比較して、体力に依存する部分はそれほど多くありません。もちろん、IT業界の一部で常態化しているという、“徹夜当然”のデスマーチを乗り切るためには、若さと体力が必要かもしれません。\n
　しかし、ほとんどの場合、必要なのは、知識、経験、判断力などで、これらは年齢とともに大幅に低下するようなものではありません。ということは、事情さえ許せば、生涯現役プログラマというのは夢ではないということです。この辺りがプロスポーツ選手とは異なるところです。\n
　しばしば「プログラマ35歳定年説」がいわれることがあります。確かに私の周辺でも30代後半くらいから「めっきりプログラミングしてなくて」という情けない「元プログラマ」が増えていますが、それは能力の低下というより社会的な事情でしょう。優れたプログラマの価値をそれほど認めない日本のIT業界で、年功序列制度による賃金上昇と、職業的価値のバランスが取れなくなる年齢が、35歳くらいということなのでしょう。\n
　事実、海外の著名なプログラマの多くは、年齢を重ねても一線級で活躍している人が珍しくありません。日本でも、私の大学時代の指導教官であった方など、定年で退官した後の方が、事務的な雑事がないから集中できると、ばりばりとコードを量産しています。私もああいうふうに一生現役でありたいものだと思います。\n
　プログラミングは本来楽しいものであり、楽しいからこそ能力が向上し、優れたプログラマになれるのだと私は思います。「仕事だから」とかいう理由を付けて、しかめ面でプログラミングをするのはやめましょう。また、楽しいプログラミングは人生をより実りあるものにしてくれるはずです。私はそう信じています。\n
	</item>
	<item>
こんにちは、はじめまして。まつもとゆきひろと申します。世間ではRubyというプログラミング言語の作者として知られ、職業はプログラマーで自称ハッカーでもあります。この連載ではわたしたち「ハッカー」の生態や心理について紹介できればと考えています。\n
\n
ハッカーとは\n
\n
　「ハッカー」といってもネットワーク経由でシステム侵入を行ったり、パスワードを破ったりするような悪者ではありません。そういえば、最近そういう誤用をあまり耳にしなくなりましたね。\n
　ハッカー（Hacker）とは文字どおり「Hackする人」という意味です。「Hack」というのはもともとは「（斧などで）たたき切る」という意味ですが、転じて「（プログラムなどを）でっちあげる」というような意味で使われています。「でっちあげる」というとずさんな仕事に思えるかもしれませんが、実際には「素早い仕事」というニュアンスで、素晴らしくできの良いものも「ハック」ですし、その場限りの間に合わせのような仕事もやっぱり「ハック」です。そんな仕事を好むハッカーは、要するにコンピュータ（あるいはプログラムできるものすべて）にのめり込むようなタイプです。\n
　ハッカーたち自身がまとめた用語集である「jargon file」では、ハッカーをリスト1のように定義しています。長いでしょう？　それだけ「Hacker」という単語にこだわりを持っていることがうかがえます。\n
プログラム可能なシステムの細かい部分を探ったり、その機能を拡張する方法を探求したりすることに喜びを感じる人。必要最小限のことしか勉強したがらない大半のユーザーとは対照的\n
熱中して（さらには取りつかれたように）プログラミングをする人、またはプログラミングを単に理論化するのではなく、プログラミングを楽しむ人\n
ハック価値（hack value）を評価できる人\n
手早くプログラミングするのが得意な人\n
ある特定のプログラムのエキスパート、または頻繁にそれを使って仕事をする人。例えば「UNIXハッカー」\n
あらゆる種類のエキスパートまたは熱狂的なファン。例えば「天文ハッカー」\n
創意工夫をして制約を打破したり、回避したりするという知的な難問を楽しむ人\n
（誤用）あちこち調べ回って機密情報を探り出そうという悪意の詮索好き。このことから「パスワードハッカー」、「ネットワークハッカー」などといわれる。この意味での正しい用語は「クラッカー」\n
リスト1　ハッカーの定義（『ハッカーズ大辞典』、アスキー、ISBN4-7561-0374-Xの掲載要旨）\n
　ハッカーはほかの人から見て、一見不可能だと思えるようなことを現実にしてしまうことがあります。プログラミングの知識がない人、経験の浅い人からは魔法使いのように見えることもあります。「好きなことにのめり込んでいる」という意味では幸せそうですが、富とか資産とかいう単語とは無縁の人が多いようです。しかし、世の中には例外的に自分の才能を上手にお金に変える手段を見いだしているハッカーもいます。\n
\n
良いハッカー・悪いハッカー\n
\n
　システム侵入をするような悪い人がハッカーと呼ばれたのは、それがかつて「創造的な知的チャレンジ」であり、そのようなことを行うハッカーが存在したからです。\n
　たいていのハッカーは、世間一般と倫理観に少々ずれがあります。ときには法律を順守することや「良い社会人」であることよりも、知的好奇心を満たすことの方が大切だと考える気持ちは分からないでもありません。　ですが、ハッカーであることと、悪人であることとはまったくの独立です。いや、むしろ、仮に本物のハッカーがシステム侵入を行ったとしても、その動機はおそらく「やってみたかったから」、「できることを証明したかった」であって、「利益を得たい」というような犯罪的な動機ではないだろうと思います。ハッカーにはお金のような物質的欲求の低い人が多いのです。\n
\n
あなたはハッカーか\n
\n
　さて、「あなた」はハッカーでしょうか。こんなサイト（といっては失礼ですね）に訪れるくらいですから、あなたはきっとコンピュータのことが好きで、プログラミングにも関心があるでしょう。また、単なるコンピュータユーザーにとどまらず（そうだったら、Windows雑誌を読んでいるはずです）、ハッカー的特質を備えたUNIX系OSのユーザーであるということは、あなたがハッカーである可能性は十分に高いと言っても良いと思います。\n
　わたしの仮説によると、ハッカー的素質を持つかどうかは、以下の2つの条件を満たしているかどうかで決まります。\n
　1つは「クリエイターであるかどうか」です。マニア的要素を持つ人材は「コレクター」タイプと「クリエイター」タイプに分かれる傾向があります。もちろん、両方の特質を備えている人もいますが、この場合問題になるのは「プログラミングに対してどちらがより強く表れるか」です。コレクタータイプはマシンスペックや最新の機器に関心を持ち、コンピュータやソフトウェアの使い方には関心を寄せますが、クリエイタータイプは「ないなら作ってしまおう」、「ここが気に入らないから直そう」などと自分でばりばり「世界」を変えてしまいます。ですから、自分の好みにいろいろ設定できるようなソフトウェア、特にプログラミングできるようなソフトウェアを好みます。「もの作り」への情熱、それがハッカー的素質の第1要素ではないでしょうか。\n
　もう1つは「ブレーキが壊れていること」です。こういう言い方は変かもしれませんが、わたしが知っているハッカーのほとんどは、何らかの形でブレーキが壊れています。普通の人が「あ、これ無理そう、やめよう」と思うところで、ハッカーは「やればできるかも、やってみよう」と思うようです。その理由は、単なる無知だったり、無謀、根拠のない自信、あるいは人並み外れた能力だったりするのですが、とにかく人よりはあきらめが悪い、遅い傾向が見受けられます。だからこそ人のできないことができたりするわけです。最も、いつも成功するというわけではありません。しかし、ハッカー予備軍は人知れぬ失敗を繰り返しつつ、いつかハッカーへと成長するのです。\n
\n
ハッカー三大美徳\n
\n
　今や知らぬ人などいないスクリプト言語であるPerlの作者、ラリー・ウォール（Larry Wall）は、当代一流のハッカーです。彼によれば、プログラマーの三大美徳は、\n
無精\n
短気\n
傲慢\n
なのだそうです。もちろん、ここでの「プログラマー」はハッカー的特質を備えた人のことです。\n
　しかし、「無精」だの「短気」だの「傲慢」など、どう考えても短所にしか思えないような特質が「美徳」とはいったいどういうことでしょう。ラリー自身の言葉を引用すれば、これらの定義はリスト2のようになっています。「楽をするためには苦労をいとわない」という変な話なのですが、ハッカーは自分の知的欲求を満たさないことには指一本動かすのも嫌がる一方で、自分のやりたいことにはどんな苦労も苦労と思わない傾向があります。また、短気と傲慢のせいで、自分がコンピュータのために働かされていることを嫌います。コンピュータに与えるデータを作るために機械的作業を繰り返すくらいなら、機械的作業をコンピュータにやらせるスクリプトを作ろうとします。あるいは、今後そのような作業を一切しなくても良いようなツールの開発を開始するかもしれません。普通の人には本末転倒に見えるかもしれません。でも、それがハッカーなのです。\n
　この連載では、そんなハッカーたちの生態や心理を観察していこうと思います。ハッカーの生き方は、あなたがより良いプログラマーになるのに役立つかもしれません。保証はできませんけど。\n
	</item>
	<item>
キーボードと鞍\n
\n
　生産性にこだわる職人は、自分の道具を選びます。現代のコンピュータ職人が最も接する道具といえば、キーボードではないでしょうか。今月はハッカーのキーボードへのこだわりについて考察します。\n
　ハッカーのキーボードとして最も有名なものはHappy Hacking Keyboardでしょう。これは国内ハッカーの「はしり」とでも呼ぶべき、東京大学の和田英一名誉教授*の監修で企画された商品であり、「UNIXハッカーのためのキーボード」と高く評価されています。特徴としては、こだわりのキースイッチ、Sun Type3キーボード*互換のキー配列、最小限のキー数*とそれによるサイズの削減などがあります。和田教授のキーボードへのこだわりは、以下のような談話からもうかがえます。\n
米国西部のカウボーイたちは、馬が死ぬと馬はそこに残していくが、どんなに砂漠を歩こうとも、鞍は自分で担いでいく。馬は消耗品であり、鞍は自分の体に馴染んだインタフェースだからだ。今やPCは消耗品であり、キーボードは大切な、生涯使えるインタフェースであることを忘れてはいけない。\n
　最近では、PCは数年で性能が陳腐化します。CPUが遅い（遅くなるのはCPUではなくソフトウェアなのですが）、HDDの容量が足りないなどの不満から、どうしても買い替えてしまいます。しかし、手になじむ高品質のキーボードは、PC本体を買い替えても、ずっと使える大事なインタフェースであるというのは分かる気がします。日常接する時間の長いインタフェースであればこそのこだわりであると言えるでしょう。\n
\n
十人十色\n
\n
　キーボードに対するハッカーのこだわりは、いろいろな形で現れます。知人のPerlハッカーは、アルファベット入力にDvorak配列*を使い、日本語入力にT-Code*を使っています。キーボードやキー配列にこだわる知人は多いですが、DvorakとT-Codeの両方を使っているのは彼だけです。\n
　これまたハッカーとして知られる産業総合研究所の増井俊之さんは、キーボードの配列を変更しているようです。Rubyist Magazine*第5号のインタビューによれば、最近あまり使わなくなったセミコロン（;）をEnterキーと置き換えてしまったのだそうです。\n
増井　それから、最近気がついたことは、セミコロン打たなくていいですよね、あんまり。キーボード入力してる時、セミコロンって小指にあるじゃないですか。これは非常にいいポジションなんだけど、CとかPerlでは打つけど、Rubyでは打たなくていいですよね。で、使わないキーがこんないいところにあるのはもったいないから、これリターンにしちゃったんですよ。\n
一同　（爆笑）\n
増井　だから、わたしの機械は今全部、右手の小指がリターンなんです。すると手を全然動かさなくていけるんですよ。普通の人は、バックスペースで右手を動かすし、リターンでも動かすから、かなり無駄なんですよ。日本語を入力しててもかなり手が動いてるはずです。でも、ここをリターンにしてから、ほとんど手を動かさずに舐めるように入力できるようになりましたよ。\n
　Rubyに合わせてキー配列を変えるというのも、「ブレーキが壊れている」ハッカーらしい態度ですね。このインタビューには、ほかにも増井さんのハッカー的人格の原点がうかがえるエピソード*がたくさん載っていますから必読です。\n
\n
日本語入力の配列は「きゅうり改」\n
\n
　さて、わたし自身のことも話しておきましょう。ノートPC派のわたしは、和田教授のような「一生もののキーボード」というわけにはいきません。\n
　それでもキー配列に対するこだわりはあって、まずアルファベット入力には、日本語キーボード（いわゆるJIS配列）を英語配列（いわゆるASCII配列）で使っています。これは「A」の段で「Enter」の隣にあるキーの数が気になるからです。英語キーボードでは、ここにキーがないため「`」キーが変なところにさまよっている*のが気に入りません。また、JIS配列では「[」と「]」が縦に並ぶのも不満です。「（」と「）」はちゃんと横に並んでいるのに。わたしがASCII配列を好むのは、最初に就職した会社で使ったソニーのワークステーション（NEWS）のキーボードが、この「ASCII配列だがEnterの横にキーが多い」タイプだったことが原因の1つかもしれません。\n
　キー配列のこだわりはもう少しあって、実は日本語入力用のキー配列に独自のものを定義しています（図2）。わたしはこの配列を「きゅうり改」と呼んでいます。\n
　「きゅうり改」は左手が子音、右手が母音となるキー配列です。例えば、「G」のキー（実際にはアルファベットのQキー）を押してから「U」のキー（アルファベットのJキー）を押すと「ぐ」が入力されます。基本的に左手と右手が交互に動くので、リズム良く入力できます。\n
\n
図2 日本語入力配列「きゅうり改」\n
「きゃ」のように拗音（ようおん）を含む文字は、子音キーの後に「ゃ」キーのような拗音（ようおん）キーを打ちます。それ以外の小文字は「小」キーを使い、\n
「H」「小」「A」→「ふぁ」\n
というように入力します。ローマ字入力であいまいになりやすい「ん」と「っ」は独立したキーが割り当てているので、「な行」と「ん」が交ざってしまったとか、「っ」で終わる文章が打ちにくいとかいう問題とも無縁です。\n
　日本語変換システムとしてCannaを使用している方は、わたしの使っているkpdefファイルを利用することにより、「きゅうり改」を試してみることができます。kpdefファイルはこちらからダウンロードしてください（編注：2007年4月24日現在、ファイルにアクセスできない。詳しくはこちらを参照）。\n
　Canna付属のmkromdicを使って、kyuri.kpdefファイルからローマ字かな変換テーブル（ドットで始まる名前のファイル）を作ってください。後は、その変換テーブルをホームディレクトリに置き、.cannaファイルに、\n
（setq romkana-table &quot;&lt;変換テーブル名&gt;&quot;）\n
という行を追加すると、「きゅうり改」が使えるようになります。&lt;変換テーブル名&gt;の部分は、作成したローマ字かな変換テーブルのファイル名にしてくださいね。\n
　「きゅうり改」は完全にわたしのオリジナルのアイデアというわけではなく、もともと狩野宏樹さんが1991年に作成された「きゅうり*」という配列に触発されて誕生しました。確か1992年ごろだったと思うのですが、キー配列のカスタマイズに凝っていたわたしは、日本語入力に「きゅうり」を使おうというアイデアに取りつかれました。しかし、実際に使ってみるとちょっと使いにくいところがあったので、自分の指の癖に合わせて打ちにくいキーを移動したり、拗音（ようおん）の連続で「ゃあ」、「ょう」、「ゅう」などを入力できるような改善を行い、「きゅうり改」が誕生しました。\n
　日本語入力の配列をまったく新しいものにするのには少々勇気が必要でしたが、やってみたら3日で慣れました。プログラマーといってもプログラムばかり書いているわけではなく、ドキュメント書きやメール書きなど、日本語を入力する割合の方がはるかに多いので、日本語入力の効率は非常に重要です。「きゅうり改」はわたしの生産性を高めてくれています。\n
　このように手になじむ道具の追求は、ハッカーの特質の1つです。皆さんも身の回りのツールの使い勝手を極めてみませんか。ハッカーの気持ちが分かるかもしれません。\n
	</item>
	<item>
ハッカー傾向のある人々は、正直あまりビジネス向きではないように思います。なにしろ彼らの美徳は「不精」「短気」「傲慢」ですし、好きなことにはのめり込むタイプですが、逆に嫌いなことはあまり我慢しないかもしれません。しかし、ビジネスとはそんなに甘いものではないはずです。\n
　ハッカーも人間です。眠たくもなれば、お腹も空きます。いくらハッカーでも、霞（かすみ）を食べて生きていくわけにはいきません。そこで今回は、ハッカーの仕事生活を紹介しましょう。もっともわたしの周辺のごく限られたサンプルからの情報なので、独断と偏見があることはあらかじめご了承ください。\n
\n
論文や卒業がネック\n
\n
　ハッカーが多く見受けられるのは、やはり大学や研究機関です。大学や研究機関から生まれた「ハッカー技術」は、UNIXやC（AT&amp;Tベル研究所）、BSD（カリフォルニア大学バークレー校）、TeX（スタンフォード大学）などをはじめとして、数多く存在します。この半世紀、研究職ハッカーがコンピュータサイエンスを発展させてきたと言っても過言ではありません。\n
　これらはハッカーの知的探求心を満足させつつ、職業として成立する貴重な分野です。ハッカーにとって理想的と思えるでしょうが、世の中それほど甘くありません。研究社会では、主に論文によって業績が評価されます。プログラムを作ることが大好きで、それだけをやっていたいソフトウェア系ハッカーにとって、論文書きはそれなりに苦痛を伴います。人類全体への貢献を考えると、プログラミングが得意なハッカーにはプログラミングだけをさせておいた方がためになるような気もしますが、社会の仕組みはそうなっていないようです。\n
　大学の職員ではなく、学生ハッカーも見逃せません。学生は若さとそれに伴う行動力に満ちあふれていますし（そうでない人もいますが）、また時間に余裕のあるケースが多いので、なかなか面白い作品を作り上げることもあります。学生の作品として最も有名なものは、ヘルシンキ大学時代のリーナス・トーバルズ（Linus Torvalds）氏によるLinuxがあります。学生ハッカーには試験やアルバイトといった障害もさることながら、「いつかは卒業してしまう」という厳しい（？）現実があります。Ruby界でもそのような例があり、一番印象的なのは、Intelのx86系を対象にしたJITコンパイラrubyjitと、同じ作者によるRubyをCに変換するrb2cです。いずれも非常に面白いプロジェクトだったのですが、作者の卒業に伴って開発が中止してしまい、後を継ぐ勇者が現れませんでした。残念なことです。\n
\n
本業と副業が逆転\n
\n
　学生が卒業すると、就職することになります。大学に残り研究員になるケースについてはすでに述べたので、ここでは企業に就職した場合について考えてみましょう。なお少数ながら、就職して業務でソフトウェアを開発するうちにプログラム開発の面白さに気づいてハッカー魂に目覚める「社会人デビュー組」もいます。\n
　社会人ハッカーの多くは「副業タイプ」です。本業の仕事は業務命令としてこなしつつ、本当に面白いプログラミングは自分の趣味として行います。仕事の合間とか、帰ってから自宅でとか、寝る時間を削ってとか。まあプログラミング以外の趣味を持つ人はたくさんいるわけですから、それと同じだと考えられます。食べるためにそれなりの仕事をして、自分の趣味のためにプログラミングをする。なかなか安定したライフスタイルかもしれません。\n
　問題はハッカー的人格にあります。ハッカーはブレーキが壊れている傾向があるため、ついつい好きな方にのめり込んでしまいます。また、成果をオープンソースソフトウェアとして公開したりすると、そのソフトウェアのユーザーが増えるにつれ、サポートやメンテナンスなどにかかる時間が半端でなくなってきます。わたしも最初は、社会人プログラマーの余暇としてRubyの開発を始めました。数年は仕事の合間を縫って開発してきましたが、Rubyのユーザーが増え、メーリングリストのメールが1日数十通を超えるようになると、そのメールを読んで返事を書き、報告されたバグを修正するだけでも、1日の大部分を消費するようになります。そうなると破たんが見えてきます。ここで、副業タイプのハッカーは次のアクションへの選択を迫られます。\n
\n
次の一手\n
\n
　考えられる選択肢は幾つかあります。すぐに思いつくのは以下のようなものでしょうか。いずれも実際に行われている選択肢です。\n
フリープログラマーになる。仕事をする期間と「ハックする」期間を明確に分ける\n
上司を説得してハッカーというものを理解してもらう\n
ハッカーに対して理解のある職場に転職する\n
起業する\n
　フリープログラマーというのは安定性に欠けるのが難点ですが、自分の思いどおりの仕事ができます。ただし、自分で仕事を見つけるためのコネクションが不可欠ですし、自己管理能力も求められます。ハッカーには、自己管理能力の弱い人が多いようにも思われますが。\n
　上司を説得した例としては、WideStudioの平林さんがいらっしゃいます。彼はIPA*の「未踏プロジェクト*」に応募し、スーパークリエーター*に認定されることで上司に理解してもらい、自分のハックの成果（＝WideStudio）を仕事として認めてもらうことに成功しました。このように、未踏プロジェクトを利用して自分のハックを世に認めてもらった人は多いようです。\n
　わたし自身は、転職によって居場所を見つけました。1997年に現在の職場であるネットワーク応用通信研究所に転職したわけですが、転職の際には「Rubyの開発者」として採用していただきました。この会社はハッカーの扱い方を心得ていて、居心地の良い職場環境を提供してくれています。おかげで転職以来8年間、快適に仕事をさせてもらっています。ハッカーの多くは経済的成功への野心が少なく、食うに困らない収入があれば、適当に面白い仕事と技術的チャレンジ、およびほかのハッカーとの良好な交流があるだけで満足します。ハッカーの生産性は「普通の技術者」の数倍から数十倍に相当しますから、会社にとっても十分にお得なわけです。また、有名なハッカーには企業の看板、あるいは広告塔としての働きもありますから、そこでも有効に活用できます。\n
　ハッカーと言ってもいろいろな種類の人間がおり、中には野心のあるタイプの人もいます。プログラムをハックするというよりも、技術を生かして社会をハックするといった感じでしょうか。ベンチャー文化が発達した米国では、ハッカーによる技術を前面に押し出したベンチャービジネスが幾つも見受けられます。成功して大金持ちになるハッカーもいるわけです。例えば、Lispを「秘密兵器」としたViaWebというインターネットショッピングASP事業で成功した（『ハッカーと画家』*の、と言った方が有名でしょうか）Paul Graham氏、Netscape Navigatorのリードプログラマーとして有名なMark Andreessen氏などがいます。あまり起業とかベンチャーが盛んではない日本では目立った「起業ハッカー」はいない*のですが、日本の将来のためには社会が変化して、このようなハッカーがどんどん出てくるようになった方が良いのではないかと思います。\n
\n
Win-Winの関係\n
\n
　ハッカーは悪い側面だけが強調されてしまうと、社会適合性の欠けたただのぐうたら社員ということになってしまいます。けれども、ハッカーたちは、実は優れた生産性を持つプログラマーであるだけでなく、新しい技術への鋭敏なアンテナの持ち主でもあります。このような人材は、活用の仕方によって企業の「秘密兵器」になり得るのではないでしょうか。ハッカーは知的好奇心を満足させるプロジェクトや住み心地の良い環境を手に入れてハッピー、企業は優れた生産性を活用して業績を上げてハッピー、という構図が一般的になると良いのですが。\n
	</item>
	<item>
論争のタネ\n
\n
　ハッカーといっても一枚岩ではありません。いろいろな種類のハッカーがいます。悪ぶっているだけの「自称ハッカー」は論外としても、いろいろな趣味、いろいろな文化のハッカーが存在します。そして彼らは、自分の意見や文化についてしばしば論争を起こします。そのような論争のテーマはたくさんありますが、典型的なものは「どのプログラミング言語が一番優れているか？」、「どのOSが最も良いか？」、または「サイコーのエディタはEmacsかviか？」などです。今回は最後に挙げた「Emacsかviか」を例に、ハッカー文化圏について眺めてみましょう。\n
\n
TECOから進化したEmacs\n
\n
オリジナルのEmacsは、リチャード・ストールマンがTECOエディタ用に開発したマクロです。リチャード・ストールマンといえばGNU活動で有名になりましたが、もとは超一流のハッカーで、ばりばりプログラムを書く人物であることを忘れてはいけません。TECOはマクロ機能を備えたラインエディタで、ストールマンはそのマクロ機能を駆使して、スクリーンエディタである最初のEmacsを書き上げたわけです。\n
　TECOによるEmacsが実装されたのは1976年だといわれています。その後、Javaの設計者となるジェームズ・ゴスリングが1981年にUNIX版Emacsの開発を行います。ゴスリングによるEmacs（通称Gosling　EmacsまたはGosmacs）は、MockLispと呼ばれるLispもどきの言語を使った拡張機能を持っていました。しかし、ゴスリングはGosmacsの権利をUniPress社に売却してしまい、ストールマンはGosmacsをベースにした新しいEmacsの開発を行えなくなってしまうのです。\n
\n
　いずれにしても、UniPress Emacsをベースに作業することができなかったストールマンは、再びゼロからEmacsを開発しました。これが現在広く使われているGNU Emacsです。GNU EmacsはGosmacsの拡張性を参考にしていますが、MockLispのようなまがいものの言語ではなく、より「ちゃんとした」LispであるEmacs Lispを内蔵しています。Emacsの本体は基本的な編集機能とEmacs Lispを内蔵しているだけで、便利な機能のほとんどはEmacs Lispを使って後付けで実装されています。ということは、一般のユーザーもEmacsの基本機能をベースにしてさまざまな機能を実装できるということです。事実、Emacsではプログラミング言語を支援する各言語モードなど、さまざまな編集支援機能がユーザーからの寄贈によって追加されています。また、エディタの機能を超えて、メールリーダー、ニュースリーダー、Webブラウザ、ゲームなどなど、あらゆる領域での拡張機能が提供されています。Emacsはもはや単なるエディタではなく、1つの環境、あるいは一種のOSと呼べるくらいにまで発展しているわけです。\n
\n
edから進化したvi\n
\n
　viはVisual Editorの略だといわれています。BSDの立役者で、長らくサン・マイクロシステムズの副社長だったビル・ジョイによって1976年ごろに開発されたviは、UNIXの標準ラインエディタであったedおよびexをベースにスクリーンエディット機能を追加したものです。edマクロによる非対話モードの作業を簡単に行える点がメリットであり、いつでもラインエディットに戻れる安心感があります。最近では、どちらも必要になることは珍しくなりましたが、わたしが学生のころは端末がおかしくなってviをラインモードで使う*こともときどきありました。\n
　そういえば、学生時代の友人で普段からラインエディタedを愛用していたEくんは、ある日「lessのように画面を直接見ながらedコマンドで編集できるエディタがあれば完璧だ。lessedと名付けよう*」といいながらlessのソースコードをハックしていました。見かねて「それはviというものなんだよ」と教えてあげたら、彼は感動していました。1988年のことです。毎日UNIXを使いながらviを知らなかった彼は大物なんだか、変人なんだか。\n
\n
ニュージャージー対マサチューセッツ\n
\n
　viはUNIX哲学の体現だといえます。ニュージャージー州にあるAT&amp;Tベル研究所で始まったUNIXの哲学は、「単機能のツールを組み合わせた柔軟性」です。UNIXツールのことを良く知る人なら、各種フィルタを組み合わせた「パイプライン処理」のことを思い起こすはずです。cat、grep、awk、sed、nroff、pic、tblなどの単機能ツールをパイプラインでつなげて加工するのは、職人芸といっても良いでしょう。UNIX哲学では、もちろんエディタもそのようなツールの一種と見なされます。2つのファイルの差分を取るツールdiffは、「-e」オプションを指定するとed形式で出力します。この出力結果の最後に「w」を付加してedに渡すと、自動的に書き換えて保存してくれます。最もこのやり方では、ファイルが少しでも変更されていると悲惨な結果になるので、最近はedよりも少し賢いpatchコマンドを使うことがほとんどでしょうけど。\n
　このようにviは、「小さいことは良いことだ」あるいは「よけいなことはしない」という思想を反映したツールなのです。\n
　一方のEmacsは、また違う思想を反映しています。いまではUNIXで使われることが多く、UNIX系エディタと見なされやすいEmacsですが、オリジナルが開発されたのはUNIX上ではありません。\n
　Emacsが反映している（と思われる）のは、MIT（米マサチューセッツ工科大学）のLisp文化です。Lispは1958年ごろにMITで誕生*しました。もうすぐ50年になるんですね。ほとんどのLisp処理系は対話的に処理を行い、必要となる関数を次々に定義していくことで環境を整備するという開発スタイルを取ります。このような環境で育ったLispハッカーにとって、Lisp処理系に編集機能を追加し、エディタにまで育て上げるというアプローチは、ごく自然なものだったのだろうと想像します。1970年代、ストールマンが名うてのLispハッカーであったことを考えると、「彼にして、このエディタあり」ということだったのでしょう。\n
　Emacsの魅力はその拡張性、さらにいえばその「プログラム可能性」です。Emacsを開発のベースに使えば、画面操作などの標準で備わっている基本的な機能を利用して効率良くプログラムを開発できます。わたし自身、日常的な編集を支援するEmacs用の小さなツールをたくさん書いていますし、さらにRubyの編集とインデントを支援するrubymode、Emacs上のメールリーダーを2つ（cmailとmorq*）開発しています。\n
　しかし一方で、Emacsはエディタでありながら、あらゆる機能を飲み込んでいってしまい、どんどん複雑化、肥大化しています。これを称して「キッチンシンク」と呼ぶ人もいます。\n
　小さいツールを組み合わせることによって柔軟性を提供するUNIX思想、プログラム可能なツールによる柔軟性を提供するLisp思想。2つのエディタの対立は、2つの思想の対立でもあったのです。\n
\n
NASAの乱入\n
\n
　しかし、後にEmacsがUNIX上の代表的なエディタと見なされるようになって、戦況はやや混乱します。どちらもUNIXの仲間と思われてしまい、それまでのUNIX対Lispという分かりやすい対立軸が見えにくくなったからです。そして、別の「キッチンシンク」であるPerlの参戦によって、この対立軸は完全に見えなくなります。\n
　Perlは、UNIX系文化が個別のツールで提供していた機能をすべて1つの言語で提供しようというアプローチのものです。開発者のLarry Wall（当時、NASAのジェット推進研究所所属）がLisp系文化の影響を受けていたかどうかは定かではありませんが、「キッチンシンク」アプローチの有効性を広く示したことには変わりありません。結果的に、PerlはUNIX文化とLisp文化の架け橋になったといえるでしょう。\n
　皆さんも「Emacs対vi」の論争を見たら、それは遠い昔にあったUNIX対Lispの思想の名残だと思ってください。思想は形を変えながら、いまもハッカー文化の中に息づいているのです。\n
	</item>
	<item>
環境を改変していく能力\n
\n
　「環境問題」といっても、地球温暖化などの話ではありません。ハッカーが生活する空間、つまりコンピューティング環境のお話です。\n
　地球上には数えきれないほどの種類の生物が生息していますが、人間ほど広い範囲に住んでいる生物はいないでしょう。赤熱の赤道直下から極寒の極地までカバーしています。これは生物としての耐久力が高い*からではありません。人類の繁栄は、衣服や住居によって自分の周囲の環境をコントロールすることで実現されているのです。どんなに外が寒くても快適な住居を作り上げる能力、暖房や冷房などを発明する能力、そして何よりも自分の周囲の環境を積極的に改変していこうという意欲、これこそ人類が地球を実質的に支配している理由でしょう。もっとも、積極的に地球環境を改変しすぎて、環境バランスを崩しそうになっていることは大問題ですが、それはまた別の話です。\n
　そんな人類ですが、コンピュータの登場によって誕生した「電脳空間」の環境を積極的に改変していく能力は、まだ誰もが持っているとは言いがたいようです。\n
\n
世の中にあふれかえるコンピュータ\n
\n
　現代では、20年以上前とは比べものにならないくらい大量の、しかも高性能のコンピュータが人々の周りに満ちあふれています。最近のコンピュータは昔のスーパーコンピュータをはるかにしのぐ性能を持っています。また、数の点での発展も目覚ましく、テレビやカメラ、車に炊飯器などにもコンピュータが内蔵されています。日本などの先進国では、すべての人が何らかの形でコンピュータを所有しているのではないでしょうか？　また、ほとんどの人が所有している携帯電話は、通話機能とネットワークアクセス機能を持った携帯型コンピュータそのものです。電車の中や道端でケータイに向かってピコピコやっている姿を見ていると、すごいことが現実になったものだと感心します。携帯型コンピューティングデバイスを誰もが持っていて、日常生活で頻繁に利用するなどとは、SFの中でしか描かれなかった未来像です。\n
　また、組み込みでない汎用型コンピュータ、いわゆるPC*の普及率も高く、コンピュータ人口は昔に比べて格段に増加しています。しかし、ほとんどの人は、コンピュータを特定の仕事を果たす道具として利用するだけで、Webページをブラウズしたり、ワープロソフトで文書を作成したり、表計算ソフトで集計したりはするものの、プログラミングすることはほとんどありません。わたしの家族もごたぶんにもれず、多少はPCを使うようになりました。子どもたちの学校には「パソコン室」なるものがあり、ある種の情報リテラシのような授業が存在します。そのせいか、わたしがいないうちにPCの電源を入れて、インターネット経由でアニメを見たり、ゲームを楽しんだりしているようです。\n
　道具としてコンピュータを使う、与えられた機能を与えられたままに使いこなす。それはそれで悪いことではないのですが、与えられた環境に自分を適合させるというのは、人類としては退化しているように感じます。実際に情報系の大学では、コンピュータを使ったことはあるが、プログラミングについては何も知らない新入生が大量に入学して当惑する事態が頻発しているそうです。\n
\n
プログラムによるカスタマイズ\n
\n
　わたしがコンピュータにはじめて接したころ、コンピュータはプログラミングのための道具でした。BASICしか載っていないコンピュータでは、できることなどたかが知れていましたが、それでもプログラミングは楽しい経験でした。当時のコンピュータ*のユーザーは、ほぼ全員が何らかのプログラミングを行っていました。あのころのコンピュータは非力で、機能も少ないものでしたが、プログラミングによって「自分のやりたいことをやらせている」という感覚が味わえたものです。こうしてみると、この20数年の間にコンピュータというもののありかたは、すっかり変化してしまったようです。\n
　しかし、いまも昔も変わらず、ハッカーという人種は「無精」で「短気」で「傲慢」なので、与えられた環境にそのまま満足するとか、環境に自分を合わせるなどということには我慢ができないものです。ハッカーは「電子計算機」であるコンピュータを前にして、電卓をたたくなどということには耐えられません。彼らは「傲慢」なので、そのようなことは自分がコンピュータの奴隷になったように感じますし、「無精」なので単純作業の繰り返しに我慢ができません。また、「短気」なのでそのような苦痛から逃げ出すためにあらゆる努力を行い、その作業を自動化するプログラムを作り上げてしまうでしょう。\n
　このことこそが、ハッカーの多くがLinuxなどUNIX系OSを愛好する理由だと思います。Windowsなどとは違い、UNIX系OSではカスタマイズの余地が非常に大きいのが特徴です。気に入らない部分があれば自分の手になじむようにカスタマイズする。これがハッカーのやり方です。\n
　わたしが長らくEmacsを愛用しているのも同じ理由です。前回も紹介しましたが、Emacsはコア部分以外のすべてをEmacs Lispによる拡張機能として実現しています。欲しい機能があれば、Emacs Lispでプログラミングすることですぐに追加できます。15年以上Emacsを使ううちに、.emacsファイル*に蓄えられている自分用のEmacs Lisp関数は相当の分量になっています。あまりにカスタマイズしている*ため、ほかの設定ではEmacsを使いこなせません。また、わたしの.emacsでは、ほかの人は当惑することでしょう。\n
\n
ハッカーはオールドタイプ？\n
\n
環境を改善して省力化を実現するためには、スクリプト言語も有効です。データから数値を抽出して集計するために、紙に印刷してから電卓をたたくなどという苦行を行う代わりに、小さなスクリプトを書いて計算させた方が、よっぽど生産的です。例え電卓をたたくよりプログラミングに時間がかかったとしても、それはそれでいいんです。\n
　単純作業を繰り返すよりは、プログラミングという生産的な作業を行った方が100倍幸福です。Ruby、Python、Perlなどのスクリプト言語は、まさにそのような「ハッカーの道具」として電脳環境の改善を目的として誕生したのです。\n
　先日、電気工事のミスによってオフィスのサーバ室が停電になってしまい、UPSをつけていなかったマシンがすべて止まってしまいました。わたしのメールボックスが置いてあるマシンもこれに巻き込まれ、ネットワーク経由でメールが取り出せなくなったのです。メールボックスの一部にゴミが交ざったため、POPサーバが誤動作するようになったようで、ユーザー認証に失敗してしまいます。なぜ、メールボックスが壊れたくらいでそんな事態になるのか理解不能ですが、このままではメールの読み書きができず、わたしにとっては死活問題です。しかしハッカーたるもの、このようなときも慌てず騒がず*、壊れたメールボックスを手元にコピーして、簡単なRubyスクリプトで切り出し、メールクライアントに読み込みました。与えられた環境でしか生きられなければ、このような事態には手も足もでなかったことでしょう。\n
　ハッカーはただ単にコンピュータを使うだけでなく、その背後にあるソフトウェアの仕組みを理解し、必要であればその仕組み自体を変えてしまう力を持っています。その力の源は「プログラミング」なのです。電脳環境をプログラミングすることで、与えられたソフトウェアを使うだけでは実現できない魔法のような力を発揮できる。それがハッカーのパワーなのです。\n
　このように見てみると、ハッカーは電脳世界の進化の最前線にいるように思えてきます。しかしよく考えてみると、現実世界でも文明が進歩するにつれて専門化が進み、ほとんどの人は自分で家を建てたりはしません。自動車を作ったりもしません。やるのはせいぜい趣味の日曜大工程度でしょうか。それと対比するならば、あらゆることを自分の手で改造しないと気が済まないハッカーは、進化の最前線どころか時代に取り残されたオールドタイプなのかもしれませんねえ。まあ、自分で何にもできないユーザー*よりは幸せですが。\n
	</item>
	<item>
言語へのこだわり\n
\n
　ハッカーは、プログラミング言語にこだわる人がとても多いことで有名です。例えば、『ハッカーと画家*』などの著書で知られるPaul Graham*はLispに大変こだわっており、著書やエッセイの中でLispのパワーについてたびたび熱く語っています。わたし自身もプログラミング言語に深いこだわりを持つハッカーであり、「言語おたく」を自称しています。わたし以外にもプログラミング言語好きのハッカーは数多く、中にはそれを本職にしてしまっている「言語屋」と呼ばれる人たちも存在するほどです。\n
　では、なぜハッカーはここまで言語にこだわるのでしょうか。それはおそらく、プログラミング言語がハッカーの力と密接な関係があるからだと思います。前回、プログラミングがハッカーの力の源であると述べました。そして、そのプログラミングが言語を通じて行われる以上、言語はハッカー最強の道具です。ですから、どのような言語をどのように使うかは、ハッカーの力の大きさに直接関係してきます。ハッカーは自分の能力や道具の良しあしにとても敏感ですから、どうしても言語にこだわってしまうのでしょう。\n
　いわゆる「普通の人」には、この気持ちを理解することは難しいのかもしれません。普段あまりプログラムを書かない人にとっては、どのような言語でプログラムを書こうとも、結局はアルゴリズムを記述しているわけであり、その本質に大差はないと感じることでしょう。確かにチューリング完全*な言語であれば、任意のアルゴリズムを記述可能だそうですから、数学的には（ある一定の条件を満たす）すべての言語は等価なのかもしれません。しかし現実には、すべての言語は等価ではないのです。\n
\n
思考表現の手段としての言語\n
\n
　たとえ理論的には同じアルゴリズムを記述したとしても、言語が違えばその表現は大きく異なります。そして、その表現の違いが言語の違いを生むのです。プログラミング言語というものは、プログラムというコンピュータに対する仕事の手順を記述するものですから、その対象はコンピュータであると考えがちです。しかし、実際に言語によって影響を受けるのは人間の方です。言語は人間の思考をコンピュータに理解できる形で表現する手段なわけですが、同時に思考の道具でもあるのです。\n
　自然言語学には「人が話す言葉と、物事の理解の仕方や振る舞い方には密接な関係があるのではないか」という「Sapir-Whorf仮説」というものがあります。わたし自身も日本語で話しているときと英語で話しているときで性格が違うような気がする*ので、個人的な経験からはこの仮説が成立していそうなのですが、実際にこれが正しいことを示す学術的な証拠は見つかっておらず、どちらかといえば否定されているっぽい仮説です。しかし、自然言語についてこの仮説が正しいかどうかにかかわらず、使用するプログラミング言語によってプログラマーの発想が影響を受けるのは事実です。\n
　わたしがBASICユーザーだった中学生のころ、関数が自分自身を呼び出す再帰という考え方が理解できず、3日間Pascalの教科書とにらめっこした覚えがあります。まあ、手元にPascalの処理系があって実行できればもっと早く理解できたのかもしれませんが、当時は自分で自由に使えるコンピュータを（BASICポケコン以外は）所有していませんでしたから。もしわたしが最初に使った言語がLispだったりしたら、おそらく再帰という考え方に違和感を覚えることはなかったでしょう。\n
　このことから、「より強力な言語を使うことは、プログラマーがより良い発想を持つ助けになる」ということが分かります。言語の選択は、プログラマーの能力に影響を与えるのです。また、一度学んだ発想はほかの言語を使うときにも応用しやすいので、新しい言語を学ぶことはより優秀なプログラマーへの近道でもあります。名著として知られる『達人プログラマー*』の中で著者たちは、「1年に1つ新しい言語を覚える」というチャレンジを提案しています。これも同じ理由からです。彼らは執筆直後にこのチャレンジを自ら実践してRubyを発見し、あまりに気に入ったので英語圏における初のRuby解説書である『プログラミングRuby*』を書いたのでした。\n
\n
プログラムを書く手段としての言語\n
\n
　このように、言語は考えることも助けてくれますが、考えるだけではプログラムは完成しません。言語の一番重要な側面は、プログラムを書くことです。\n
　さて、名著『人月の神話*』によれば、「基本的な1ステートメントを製造するのに要する工数は言語によらずほぼ一定」なのだそうです。とすれば、同じ処理を記述するときに言語Aで1000行、言語Bで10行必要であったとすれば、言語Bを採用するだけで生産性がおよそ100倍になります。「そんなバカな」と思うかもしれませんが、例えばJavaとRubyで同じ処理を記述する場合、ステートメント数で2倍以上の差がつくことは珍しくありません。アセンブラとRubyであれば、100倍どころか1000倍の差がつくケースもありそうです。プログラミング言語進化の歴史は、「いかにより簡潔な記述を可能にするか」を探し求めてきた歴史でもあります。\n
　また、言語の差よりも重大なのはライブラリがそろっているかどうかです。例えば、ネットワーク経由でHTTPアクセスをしたい場合、ソケットを用いてネットワークコネクションを確立する処理から書き始めれば、どのような言語を使っても500行以下で実現できるとは思えません。しかし、HTTPを直接扱うことのできるライブラリが用意されていれば、HTTPアクセス自体がたった1行で実現できるかもしれません。この差は大変重要です。\n
\n
プログラムを読む手段としての言語\n
\n
　ほとんどの場合、プログラミングとは一度プログラムを書いてそれで終わりというわけにはいきません。バグがあればプログラムを読み返して、本当に正しい記述が行われているかを確認しなければなりませんし、ほかの人が書いたプログラムを読んで保守しなければならないこともたびたびです。また、半年も経てば自分が書いたプログラムでも他人が書いたものと同じです。読んでみないと、何をしようとしていたのか分からないものです。もしかすると、プログラムを書くよりもプログラムを読む時間の方が長いかもしれません。\n
　一般に、書きやすい言語によって書かれた簡潔なプログラムは、無駄な「お約束」が少なく、処理の本質に集中できるので読みやすいことが多いのですが、プログラムの簡潔さと読みやすさがいつも比例するとは限りません。簡潔すぎて情報量が少ないプログラムは読解のために推測すべきことが多くなり、かえって読みにくいこともあります。例えば、書くときに面倒なだけの型情報は、読むときにはずいぶん役に立ちます。また、記号などを使って「圧縮」されたプログラムは短くても超難解です。「write-only language」とか「executable line noise」などと悪口を言われるプログラム言語もあります。特に名前を出しませんが（笑）。\n
\n
プログラム実行系としての言語\n
\n
　異なる言語によって同じアルゴリズムで同じようにプログラムを書いたとしても、同じような速度で実行できるとは限りません。プログラミング言語は、その実行形式（コンパイラ型かインタプリタ型か）や処理系の優劣によって実行性能が大きく変動するからです。ハッカーの中にはスピード命というタイプもいますし、最終的なプログラムの実行性能を重要視する人も多いです。一般に柔軟で生産性の高い言語は、実行時に行うことが多くて、実行性能が低い傾向にあります。開発時の生産性か実行時の性能か。なかなか難しいトレードオフです。\n
　ああっ、もう誌面が尽きてしまいました。言語おたくが言語について語り出すと止まりません。来月もこの続きを語ることにしましょう。\n
	</item>
	<item>
本当のハッカーの定義\n
\n
　しばらく前の話になりますが、VA Linux Business Forum 2005においてOSS Roundupという討論会に参加しました（関連記事参照）。これは、わたしを含むオープンソースに深くかかわっている5名のパネリストがオープンソースに関して自由に語る形式のものです。この中で「ハッカーとは何か？」という話題が登場しました。一番定義が緩いのは「オープンソースプログラマー」の肩書でテレビにも出演していらっしゃる小飼弾氏で、「（民主主義社会では）あらゆる人はハッカーである」と定義しておられました。それはまた極端な。\n
　でも、これをきっかけにイベントが終わった後、「本当のハッカーの定義は何だろうか？」と改めて考えました。わたしは、小飼さんほど範囲を広げるつもりはないのですが、自分の中で「ハック」という用語をプログラミングに限定しているわけでもなさそうです。あえて言語化すると「普通の人は変えられないと思い込んでいるものも、変えることができる力を持つ人」くらいでしょうか。そして、コンピュータに関連した領域では、その力の源はプログラミング能力にありそうです。コンピュータに関係ない領域でも、政治力を駆使して社会を変革する「ソーシャルハック」とかありそうな気がします。経済力と常識にとらわれない発想力で社会に大きな影響を与えるライブドアの堀江さんなどは、「ソーシャルハッカー」なのかもしれません。まあ、そんなわたしでも、何の修飾もなしに「ハッカー」という単語を使えば、やはりプログラミングを行うハッカーのことを指しますけどね。\n
\n
キーワードはINSANE\n
\n
　もっと最近の話になりますが、2005年8月1日から5日まで米オレゴン州ポートランドで開催されたO\'Reilly Opensource Convention（通称OSCON*）に参加してきました。前述の小飼さんとは、ここでもまたご一緒しました。また、デイビッド・トーマス、リッチ・キルマー、ジム・ウェイリッチなど、Rubyを通じて知り合った海外の友人と再会できたのもうれしいことです。世界中からオープンソースに関心がある人々とハッカーが集う様子は壮観でした。\n
　さて、OSCONで強く感じたキーワードはINSANEです。辞書を引くと「正気じゃない」「精神異常の」とか「気違いじみた」「ばかげた」「非常識な」とかひどい意味が並んでいますが、実際にはもっとずっとポジティブに使われています。口語で「正気の沙さ汰たじゃない」や「普通じゃない」などというときのニュアンスに近いでしょうか。この連載で何度も繰り返しているハッカーの「ブレーキが壊れている」様子をよく表現していると思います。\n
　OSCONの4日目には、ラリー・ウォール（Perl）、ラスムス・ラードフ（PHP）、グイド・バンロッサム（Python）と一緒にランチを取る機会がありました。言語デザイナーとして、こんな豪華なメンバーのランチに参加できたのは光栄の極みです。Unicode対応のやり方とか、最近のトピックについていろいろと話をした*のですが、ここでもINSANEは話題になっていました。グイドがラリーに向かって「あなたたち（Perlピープル）のINSANEさはけた違いだ」といっていましたが、これは「あなたたちは気が違っている」という意味ではなく、「われわれも確かにINSANEだが、Perlの人たちにはかなわない」というニュアンスでしょう。また、グイドは、「われわれはこれだけ後方互換性に気をつかって言語を変化させているのに、まだ変化が速いといわれる」と、ちょっと残念そうでした。確かにPythonピープルは保守的な人が多いかも。先入観でしょうか。それに比べると、Rubyはずいぶんいいかげんだなあ。\n
\n
自分言語を作るのは難しくない！？\n
\n
　正直なところ、世の中にこれだけたくさんの言語があって、それぞれに特徴を持っているのに、さらにまた新しい言語を作ろうと思いつく時点で、すでに相当INSANEでしょう。常識的な人間であれば「これだけいろんな言語があるのだから、この中から自分の目的に合うものを探そう」という発想をするはずです。そこを「自分の言語を作ろう」と思っちゃうんですから、INSANEといわれても仕方がありません。しかも、言語を作ってそれを成功させようと思ったら、ただ単に言語をデザインするだけでなく、\n
処理系を実装（誰も代わりに「自分言語」の処理系を書いてくれない）\n
ドキュメントを書き（誰も代わりに「自分言語」のドキュメントを書いてくれない）\n
Webサイトを用意（誰も代わりに……以下省略）\n
などする必要があります。なかなか厳しい茨の道ですよね。\n
　じゃあ、「自分の言語」を作るのは本当に非現実的なことなのでしょうか。まつもとがRubyを作ったのは、本当にわたしが「正気じゃない」からでしょうか。そうでないとは言いきれないのが悲しいところですが、わたしも最初からほかの人と違ったことをしたいからRubyを作ったわけではないのです。「成功しよう」とか「完ぺきなものを作ろう」とか最初から気負うから大変なのですが、実際には「作りたい」という思いがあったから作った、そして言語の設計や実装はそれほど難しいことではないから実現できたわけです。\n
　冷静に考えてみると、システムをデザインするということは、ある意味、言語に語彙を加えていくことにほかなりません。「どのような語彙（ごい）をそろえているか」は言語の性質を決定しますから、自分の言語をデザインしていることでもあります。その辺をもうちょっと突き詰めて、語彙（ごい）を越えて文法の領域にまで手を入れたくなると、アラ不思議、自分言語の出来上がり、となります。\n
　ここ数十年のコンピュータサイエンスの進歩により、言語処理系の開発は本当に簡単になりました。特別に変な文法でなければ、BNF*に似たような記法で文法を定義するだけで、コンパイラコンパイラと呼ばれるツールを使ってあっという間に構文解析器を自動生成できます。今や性能のことを第一に考えなければ、簡単な言語を作ることなんて数日あればできることです。\n
　しかし、自分言語を作ることで何かメリットがあるのでしょうか？　ええ、あるんです。\n
　1つ目のメリットは、言語処理系というものがプログラミングの中でしばしば登場するテクニックの集合体であることです。例えば、設定ファイルを読み込むルーチンなどは、言語処理系の字句解析、構文解析そのものです。また、言語処理系はコンピュータサイエンスの総合芸術ですから、処理系を実装するために用いたテクニックはあらゆるプログラミングに応用できます。\n
　また、良い言語をデザインしようという行為は、人間の気持ちをより深く考えることでもあります。つまり、インタフェースのあるべき姿について、より深い考察を行うことでもあるわけです。自分言語を作る2つ目のメリットとしては、言語レベルでの使い勝手を考えることで、プログラムの使い勝手に関するより深い経験と知識を身に着けられることがありそうです。\n
\n
一段高いプログラマーへの道\n
\n
　最後に、言語デザインはとにかく面白いです。プログラミングの世界は、結局すべてのものが言語によって表現されるので、言語を変化させることはあらゆるもののありかたを変化させることでもあります。つまり、言語のデザインは、究極の自由だといえるでしょう。このような自由を享受する機会は、それほど多くはないはずです。\n
　自分言語をデザインするという作業は、より一段高いプログラマーへの道に通じているのかもしれません。例え結果的に、その言語がほかの人にまったく使われなかったとしても……。そう思って、2004年から新しい言語の作成をテーマにしたlangsmithメーリングリスト*を運営しています。言語好きな人たちが集まって、自分の新言語を発表したり、議論したりしています。この中から未来を担う言語が登場したり、時代をリードするプログラマーが誕生したりするといいなと思っているのです。
	</item>
	<item>
オープンソース貢献者賞\n
\n
　2005年のことですが、IPAとオープンソース推進フォーラムから「オープンソース貢献者賞」なる賞をいただきました。当時受賞したのはDebianプロジェクトの貢献者として知られる鵜飼さん（日本HP）、Linuxカーネルハッカー高橋さん（VA Linux Systems Japan）、NamazuやGonzuiなどで知られる高林さん（グーグル）、そして、まつもと（ネットワーク応用通信研究所）の4人でした。第1回ということで、オープンソース界隈でそれなりに名前が知られていて、かつ実際にコードを書く人を中心に選定したというところでしょうか。いずれにしても大変ありがたいことです。\n
　本来、わたしは表に出たり、有名になったりするのはあまり好きではありません。しかし、最近ちょっと考えを変えることにしました。わたし自身が好むと好まざるとにかかわらず、「Rubyのまつもと」はこの業界では知れ渡ってしまったのですから、いまさらこれをどうにかできるものではありません。それならば、むしろ精一杯「成功」して、後に続くオープンソース開発者の模範あるいはロールモデルになろうと思うようになりました。「オープンソースをやっていても食べていけるんだ」とか、「オープンソースを仕事にして幸せそうだ」とかいうありさまを見せることもわたしの使命の1つなのでしょう。きっと。\n
　さて、今回オープンソースの貢献者の1人として認定されたわけですが、わたしがいわゆるオープンソースとかかわり出したのは、オープンソースという単語が生まれた1998年をはるかにさかのぼります。当時はフリーソフトウェア*と呼ばれていました。最初の出合いは1989年ごろで、EmacsとGCCに触れたのが始まりだったと思います。それ以来、職業プログラマーが会社のために仕事として開発したものはともかく、そのようなしがらみのないものをフリーソフトウェアとして公開するのは当然だと考えていました。フリーソフトウェアにはお世話になりっぱなしですし、それくらいは当たり前ではないでしょうか。\n
\n
フリーソフトウェア好きのハッカーたち\n
\n
　わたしに限らず、多くのハッカーたちはフリーソフトウェア（オープンソースソフトウェア）が大好きです。それはなぜでしょうか。\n
　タダだから？　それもあるでしょう。数多くの優秀なソフトウェアが無償で利用できるのは、大変ありがたいことです。わたしのノートPCには、OSとしてDebian GNU/Linux、そして数えきれないほどのソフトウェアがインストールされていますが、そのほとんどはフリーソフトウェアです。\n
　しかし、ハッカーがフリーソフトウェアを愛する最も大きな理由は、経済的なものではなく、自由です。ハッカーは自分が理不尽と感じる理由で行動が制限されることを大変嫌います。あるソフトウェアがどのように動いているか知りたくなったときには、ソースコードを読んでそれを確かめたい。ソフトウェアにバグがあったときには、自分でそれを直したい。自らの行動を制限するものがあれば、ソースコードを読み、プログラミングテクニックを駆使して、それを排除したい。それはもうハッカーの本能のようなものです。\n
　世間的に「ハッカー」という言葉に悪い意味を与えてしまったクラッカー（システム侵入者）たちも、もともとは自分たちに対する制限への過剰反応が起源です。1970年代にMITなどに生息していたハッカーたちは、自分たちの問題を自由に解決するため、ときどきかなり過激なこと*を行ったと聞いています。それだけ彼らは自由を切望し、自由を獲得するために闘争していたのです。いつもそれが正しかったとは言いませんが。\n
\n
フリーソフトウェアの起源\n
\n
　そもそも、フリーソフトウェア自体も、自由の獲得が起源になっています。昔々、ソフトウェアはハードウェアの付属物であり、コンピュータを買うとソースコードごと付いてくることは決して珍しくなかったそうです。メーカーから買ってきたコンピュータにはOSすら付いておらず、「あらゆるソフトウェアはユーザーが開発する」というケースもあったようで、同じコンピュータを購入したユーザー同士は自分たちが開発したソフトウェアを交換して、お互い助け合っていました。洗練されていませんが、いまのオープンソースソフトウェアと少し似ていますね。\n
　その後、ソフトウェアは商品となり、ソースコードは簡単に外へ出せない「企業秘密」に変貌します。昔を知るものにとっては、だんだん自由が奪われていったわけです。それでも大学に所属している人々は相変わらずソフトウェア交換を行っていたのですが、その自由も次第に商用ソフトウェアに侵食されていきます。\n
　そして、とうとう大学で細々と行われていた自由なソフトウェア交換を揺るがすような「事件」が発生します。それは、本連載の第4回「Emacs対vi」で説明したEmacsにまつわる事件です。\n
　最初のEmacsは、リチャード・ストールマンという天才ハッカーがITS*上のマクロエディタTecoを使って記述したものです。使いやすいと評判になったEmacsは数多くの派生版を生み、後にJavaの設計者となるジェームズ・ゴスリングによって1981年にはUNIX版のEmacsが開発されます。ゴスリングによるEmacs（通称Gosmacs）は、MockLispと呼ばれるLispもどきの言語を使った拡張機能を持っていました。その後、ストールマンもUNIX版Emacsが欲しいと思い、Gosmacsをベースに変更作業を行おうとしました。MockLispではなく、本物のLispを組み込んだEmacsが欲しくなったからです。\n
　しかし、ゴスリングはGosmacsの権利をUnipress*という企業に売却してしまい、ストールマンはGosmacsのソースコードをベースにして新しいEmacsを開発できなくなりました。結局、ストールマンはゼロから開発した*のですが、まさにこのとき「ソフトウェアの自由は自分で守らなければいけない」ことが明らかになったわけです。この時点で「ソースコードが公開されているだけでは十分ではない」という事実に気づいたストールマンは、世間を15年先んじていたといえるでしょう。\n
　この後、ストールマンはソフトウェアの自由を守るための団体であるFSF*を組織し、ソフトウェアの自由を保証するライセンスであるGPLを定義し、また上から下まで完全に自由なOS環境であるGNU（GNU\'s Not UNIX）を作るべく積極的に活動し始めました。\n
　いや、ソフトウェアの自由は確かに大変重要なものですが、だからといって「そこまでやるか？」といいたくなります。この辺がストールマンの「ブレーキが壊れた」部分であり、それこそ彼が真のハッカーである証なのでしょう。フリーソフトウェア運動を推し進める彼の情熱とパワーには、敬服するしかありません。驚くべきエネルギーです。でも、そのおかげでストールマンは、プログラミングに割く時間があまり取れないそうです。彼の膨大なエネルギーを純粋にプログラミングに向けることができたらどんな偉大なことが実現できていただろうかと考えると、すごくもったいないような気がします。\n
\n
フリーソフトウェアからオープンソースへ\n
\n
　ある意味、現在は幸せな時代です。オープンソースは世間の注目を浴び、膨大なフリーソフトウェアの蓄積があって、ほとんどあらゆる種類のソフトウェアのソースコードを自由に閲覧したり、必要に応じて改造や再配布も自由に行うことができます。また、プログラミングに必要な情報のほとんどは、インターネット経由で瞬時に入手できます。UUCP*のバケツリレーでメールやニュースを受け渡し、ソフトウェアの配布は磁気テープの回覧で行っていたことが神話時代のことのように感じられます。\n
　しかし、そのような幸せと自由は、過去のハッカーたち（特にストールマン）が熾烈な闘争によって勝ち取ったことを忘れてはいけません。将来、再びソフトウェアの自由を奪い去ろうとする動きが発生しないとも限りません。実際にソフトウェア特許やDRM*の領域で、その傾向がうかがえます。わたしたちハッカーとその仲間たちは、いざというときに自由のために立ち上がる備えをしておくべきかもしれません。\n
	</item>
	<item>
測定狂\n
\n
　「バカは風邪をひかない」といいますが、わたしのバカさ加減は幸い許容範囲内のようで、年に数回風邪をひきます。もっとも例年夏風邪をひくことが多いので「やっぱりバカなんだ」と思うことも多いのですが、今年はなんとか大丈夫だったようです。\n
　風邪をひくと体温計で体温を測ります。昔は水銀の入ったものでしたが、最近はデジタル体温計が主流のようです。測定が終わるとビープ音が鳴ったりして、なかなか賢いヤツです。さらに、わずか1秒で体温が分かる、耳で測定する体温計もあります。ガジェット好きとしてはぜひ欲しいアイテムですが、家族の理解が得られず、まだ入手していません。\n
　風邪をひいたときの行動は人によっていろいろでしょうが、わたしはとにかく頻繁に体温を測ります。ひどいときなど数分おきに測定して、家族をあきれさせることもあります。でも、体温を測るとなんだか自分の体のベンチマークを取っているようで楽しくなりませんか？　病気が治っていく様子がうかがえるようで、病気でしんどいときの数少ない楽しみです。\n
　日常生活における測定といえば、体重測定があります。体温ほど熱心に測定する気にならないのは、なかなか自分の望む方向に（わたしの場合は減る方向に）変化しないせいに違いありません。健康のためにはもうちょっとやせた方がいいんだけどなあ。運動もしないでコンピュータの前に座ってばかりなので、増加していないだけでも喜ぶべきなのかもしれませんが。気乗りしないといっても、数日に1回は入浴前に体重計に乗り、その結果をPDAに記録してグラフを書いていたりするんで、やっぱり測定好きなんですね。\n
\n
スピード狂\n
\n
　さて、知人のハッカーの中には何人か「スピード狂」がいます。スピード狂といっても峠で自動車レースをするわけではなくて、プログラムの実効速度を速くするために異常に熱意を燃やす人たちのことです。彼らはRubyのようなスクリプト言語は使いません。「だって遅いじゃん」。使うのはもっぱらCです。まれにC++を使う人もいますが、あまり多くはありません。「C++は（コンストラクタとか暗黙の呼び出しがあるから）実行コストが直接的に見えないので好きでない」という人が多いようです。Javaは以前に比べてずいぶん高速化されましたが、それでもまだ不満そうです。また、個人的な知人たちの中にはいませんが、高速化のためにはアセンブラを駆使する人も存在すると聞いたことがあります。最もRISC以降、単にアセンブラで書くよりCなどで書いた方が高速化されることも多いようで、アセンブラ派はめっきり数が少なくなったようです。\n
　もちろん、そんな極端な人はたくさんいないでしょうが、ハッカーの多くは何らかのスピード狂的側面を持っているようで、同じ動作となるプログラムの実行時間を短縮するという課題は燃えるものがあります。プログラムを繰り返し実行しながら「ここをいじるとコンマ何秒短縮された」などとハックを繰り返すのは、ハッカーにとってある意味大変幸福な時間です。パズルを解くときの知的チャレンジに似ているからでしょう。\n
　CでコンパイルしたプログラムをCPUで直接実行するのに比べると、Rubyのようなインタープリタ型言語の実行はだいたい100～1000倍くらい遅い*ことが知られています。では、スピード狂はまったくインタープリタ型言語に寄りつかないかというと、そうでもないようです。もともとの実行時間が長いほど、改善による時間短縮幅が大きく、より達成感を感じられるからです。インタープリタ型言語の場合、処理をどれだけライブラリルーチンで消費できるかが鍵になります。Rubyの各ライブラリルーチンはそれなりに工夫して作られていますから、上手に使いこなせば、素朴にCで実装したプログラムと同等に近い性能が出る場合もあるそうです。\n
\n
無駄な努力\n
\n
　プログラムの高速化のように、プログラムの意味を変えずに性質（実効速度やメモリ消費量など）を改善することを最適化*と呼びます。ハッカーは最適化が大好きですが、そのような最適化の努力がいつも報われるとは限りません。過去のruby-talkメーリングリストに以下のようなポスト（ruby-talk:158426）がありました。\n
　わたしの会社ではC++による3次元レンダリングソフトを利用しています。そのソフトはJavaScriptとLua*のバインディングを提供していました。LuaはRubyほど使い勝手が良くなかった上、速度とメモリの効率化のため、より面倒なプログラミングテクニックを使う必要がありました。そのテクニックは確かに効果があり、FPS*は1～2％向上していました。わたしは大変苦労してLuaのプログラムを書き、単純なシーンのレンダリングで890～910FPSを達成したことに誇りを覚えていました。\n
　しかし、昨日、C++プログラマーの1人がレンダリングアルゴリズムにある変更を行ったところ、FPSが劇的に向上しました。いままで15FPSだった複雑なシーンのレンダリングが170FPSでできるようになったのです。われわれが非常に苦労して実現した数％の向上など、10分ほどかけて適切なアルゴリズムに変更するだけで吹き飛んでしまったのです。\n
　ソフトウェア業界には、昔から「premature optimization is source of all evil（早すぎる最適化はすべての悪の源）」という諺があります。プログラムの高速化においては努力がいつも報われるとは限りません。むやみな高速化の試みは、かえってプログラムの見通しが悪くなったりする弊害の方が大きいのです。\n
\n
無駄でない努力\n
\n
　ハッカーたるもの無駄な努力をするべきではありません。天より与えられたハッキングの才能を浪費することは許されないのです*。では、努力を無駄にしないためにはどうしたら良いでしょうか。\n
　そのためには「パレートの法則」を理解しておく必要があります。パレートの法則とは「80:20則」とも呼ばれるもので、全体の8割の数値は全体を構成する2割の要素が生み出しているという法則です。19世紀後半のイタリアの経済学者ヴィルフレド・パレート（Vilfredo Federico Damaso Pareto）が発見したことから、このような名前がついています。\n
　パレートの法則から分かるのは、要するに努力が報われる2割の領域と報われない8割の領域*があり、報われない領域で幾ら努力しても無駄にしかならないということです。だから最適化を始める前に、その作業が無駄になるかならないかを見極める必要があります。\n
\n
プロファイラ\n
\n
　作業が無駄になるかどうか見極めるツールをプロファイラと呼びます。Linuxで最も有名なプロファイラはgprofでしょう。\n
　gprofを使うには、コンパイル時にccのコマンドラインオプションとして「-pg」を追加します。このオプション付きでコンパイルされたプログラムには、関数の実行状態を測定するルーチンがリンクされます。プログラムを実行すると、カレントディレクトリにgmon.outファイルが生成されます。プロファイル結果を見るには、そのディレクトリで、\n
gprof &lt;プログラム名&gt;\n
を実行します。これによって、\n
どの関数がどのくらいの時間を消費しているか？\n
どの関数がどこから何回呼ばれているか？\n
などの情報を含む長いリストが出力されます。それを調べることで、「どの関数で最も時間がかかっているか」とか「どの関数が無駄に関数を呼び出しているか」などを確かめられます。この情報を参考にすることで、より効果的な最適化ができるでしょう。\n
　実効速度を見るgprof以外にも、メモリ消費量を調べるメモリプロファイラなど、測定するプログラムはたくさんあります。\n
　正しく測定して効果的な最適化を行うことは、ハッカーの測定狂的性質とスピード狂的性質の両方を一度に満足させることができます。一粒で二度おいしい最適化、あなたも試してみませんか？\n
	</item>
	<item>
ハッカー能力を向上させる方法\n
\n
　『Code Reading*』という書籍があります。わたしが監訳をしているから言うわけではないのですが、結構良い本です。今回の「ハッカーズライフ」は、この本を読んだ人には当たり前のことかもしれません。\n
　ハッカーとしての能力を身に着けるのに優れた方法は、実際にコードを書くことと、ほかの人の書いた優れたソースコードを読むことだと思います。特にコードを読むことは普段あまり強調されませんが、他人のソースコードはいろんな意味で知恵と知識の源です。考えてみれば、わたし自身も他人のソースコードをたくさん読んで学んだように思います。\n
　「コードを読むのは勉強になる」ということで、世の中には「Linuxカーネル読書会」と称して、Linuxカーネルのソースをmain関数から読み進めていく会合もあるようです。一度出席してみたい気もしますが、わたし自身はそのような読み方でモチベーションが維持できそうもありません。何ていうのかな、相手が巨大すぎるというか。ソースコードは小説のような読み物ではないので、漠然と読んでいくことはなかなかできないものです。\n
\n
ソースコード読解の秘訣\n
\n
　わたしが過去にどのようなソースコードの読み方をしてきたのかを振り返ってみると、プログラミング能力の向上を目指したコードの読み方のヒントがあるかもしれません。\n
　まず1つは、「全体を読もうとしない」ことです。ソースコードには「物語」はないので、全体を通して読む必要はありません。面白そうなところをつまみ食いして、先人の知恵を学べばそれで十分です。\n
　もう1つは、「目的を持って読む」ことです。何かを学ぼうと思ってソースコードを読めば、効果的に読解して知識を得ることができます。例えば*、「再帰下降構文解析の実装法を学ぶ」とか、「この処理系がどのようにガーベジコレクションを実装しているか」とか、「なぜこの処理系はこんなに高速に動作するのか」とかです。プログラミングの教科書にあるコードは非常に小規模なものが多く、枠組みを理解することはできますが、実用的なプログラムでどのような問題が発生するか、あるいはそれらの問題にどう対処するかについては、あまり教えてくれません。実際に動いているプログラムは、そのような「教科書が教えてくれない話」の宝庫なのです。\n
　目的を持って読むといえば、自分のプログラムに取り込むためにソースコードを読むのも1つの重要な目的です。幸いなことに現代ではオープンソース、言い換えればライセンス的に自由なソフトウェアのソースコードがたくさん手に入ります。自分が十分に理解していない領域のコードでも、ほかの人が苦労して作ってくれたソースコードを参考にして問題解決できることは多いはずです。\n
　わたしが体験した例では、pom（phase of the moon）というプログラムがあります。pomは月の満ち欠け（月齢）を表示するプログラムです。昨年、末の娘が生まれたとき、空に見事な満月がかかっているのに感動して、ほかの人の生まれた日の月齢が知りたくなりました。で、pomを使おうと思ったのですが、あいにくエポック（1970年1月1日）以前には対応していません。そこで、BSDライセンスのpomのソースコードを入手し、Cのソースコードをほぼ逐語的にRubyに書き換えました。日付ライブラリがエポック以前に対応しているRubyでは、そのままエポック以前の日付にも対応したpom*が完成したわけです。\n
　ただし、ライセンス的に自由なソフトウェアといっても、何をするのも完全に自由なもの*はそれほどありません。ほかの人が作ったソースコードを取り込む際は、それぞれのライセンスを尊重しましょう。特にGPLは「ソフトウェアの自由」を保証するため、幾つかの制約*が加えられています。何らかの理由から制約があるのですから、無視してはいけません。\n
\n
ソースコードの読み方テクニック\n
\n
　ソースコードを読み解くときは、まずプログラム全体の枠組みを理解することが有効でしょう。プログラム全体を読む必要はないのですが、自分の欲しい情報がどこにあるのかを見つけ出すには、プログラム全体の構造のイメージをつかんでおくと便利なのです。ここで最も役に立つのはソースファイル名です。\n
　たいていのソフトウェアのソースコードは幾つかのファイルに分割されていますし、各ファイルにはプログラムの機能に関連した名前がついています。例えば、メモリ管理について知りたいときには「memory.c」とか「gc.c」などという名前の付いたファイルが怪しいといえます。\n
　それで見つからない場合には、プログラムのスタートであるmain関数（Cの場合）からたどっていくことになります。ここでもプログラム全体を読む必要はないので、個別の関数の働きは関数名から推測して、必要そうなところを探すのに集中します。\n
　ソースコード探索における最大の武器はgrepです。grepは「正規表現にマッチする行を見つける」という単純なツールですが、適当なキーワードを検索するとか、関数やメソッド、変数を探すなど、いろいろな目的に活用できます。Emacsなどgrep機能を支援するエディタでは、見つけた行に直接ジャンプすることも可能です。そのほか、関数定義に直接ジャンプするctags*や、プログラムをハイパーテキストとして参照するGLOBAL*なども役に立ちます。\n
　プログラム読解向けツールのニューフェイスは、ソースコード検索エンジンGonzui*でしょう。プログラム中の識別子をインデックス化するctagsやGLOBALとは違い、Gonzuiはさまざまな検索を支援しています。関数定義だけでなく、関数の呼び出しを見つけることもできますから、「関数呼び出しの実例から使い方を学ぶ」というような使い方にも向いています。\n
\n
良いソースコード／悪いソースコード\n
\n
　このように、ソースコード読解の経験を積むと、読みやすいソースコードと読みにくいソースコードがあることに気がつくと思います。わたしが最悪と思ったのは、（失礼ながら）Perl5のソースコードです。\n
ライブラリ手続きがpp.c、pp_ctl.c、pp_hot.c、pp_sys.cなどに分散しており、ファイル名が手続きを探すヒントにならない\n
関数定義にマクロが使われているため、ctagsのたぐいが使えない\n
内部データのアクセスにもマクロが多用されており、また極端な省略形が使われているため、名前から機能が想像できない。SvUVX（）やSvPOK_only_UTF8（）など数百の名前の意味を理解するまではソースコードを把握できないような気がする\n
　もちろん、このソースコードを書いたラリー・ウォールは一流のハッカーで、前記の点にはそれなりの理由があるのです。例えば、ソースコードファイルが機能別になっていない点は「Perl開発当時の古いマシンではオブジェクトファイルの配置によって関数呼び出し速度が異なっていたため、少しでも速度を稼ぐ意味で、頻繁に呼び出される関数を目的によらず1つのファイルに集めた」という理由がありますし、マクロの多用も「コードの繰り返しを避け、ソースコードをコンパクトにまとめる」という理由があります。分からないでもないのですが、ソースコードを読み解くという観点からは、やはりつらいものがあります。\n
　このことから、良いソースコード、読みやすいコードの書き方を学ぶことができます。ラリーには悪いけど、Perlのソースコードのちょうど反対をすればよいのです。Rubyを開発する際、Perlのソースコードも参考にしましたが、この悪い点はまねしないようにと決めていました。これによって、RubyのソースコードはPerlよりずいぶんマシになっていると思います。例によって自画自賛ですが。\n
\n
誰かのために、自分のために\n
\n
　ソースコードを読むことがハッカーの能力を高める。このことは最近になって知られてきました。ここではもう一歩踏み込んで、その効果的な読み方について考えてみました。\n
　ソースコードを書く際は、読まれることを意識するのも重要です。あなたの書いたソースコードを読む必要があるのは、見知らぬ誰かだけではなく、半年後の自分自身なのかもしれませんから。\n
	</item>
	<item>
Lispは学ぶ道具？　 使う道具？\n
\n
　エリック・レイモンド（Eric Raymond）のエッセイ「ハッカーになろう*」では、Lispのことが以下のように紹介されています。\n
LISPは、それをモノにしたときの素晴らしい悟り体験のために勉強しましょう。この体験は、その後の人生でよりよいプログラマーとなる手助けとなるはずです。例え、実際にはLISPそのものをあまり使わなくても。\n
　それに対してLispハッカーであるポール・グレアム（Paul Graham）は以下のように反応*しています。\n
彼がLispについて言っていることはよくある意見だ。つまり、Lispを学べばよいプログラマーになれる、でもそれを実際に使うことはない、と。何故だい？　プログラミング言語なんてただの道具じゃないか。Lispでよいプログラムが書けるなら、使うべきなんだ。\n
　そのとおり。あまり使われていませんが、Lispには優れたところがたくさんあります。わたしは、ポール・グレアムほどのLispハッカーではありませんが、Lispプログラマーの端くれ*として、今回はその素晴らしいLispについて簡単に紹介してみようと思います。\n
\n
Lispの歴史\n
\n
　Lispの歴史は古く、その誕生は1958年だといわれています。1958年といえば、まだほとんどのプログラミング言語が登場していない時期です。このころすでに存在していたプログラミング言語で生き残っているのは、FORTRAN（1954年）とCOBOL（1959年）くらいのものでしょう。\n
　Lispがプログラミング言語として特異なのは、もともとプログラミング言語として設計されたものではなく、数学的な計算モデルとして設計されたことに原因があると考えます。Lispの設計者として知られるジョン・マッカーシー（John McCarthy）は、それが計算機言語として使えるとは考えもしませんでした。単なる計算モデルとして記述した万能関数evalを、彼の研究室の大学院生であるスティーブ・ラッセル（Steve Russell）がIBM 704の機械語で実現したことによって、はじめてプログラミング言語Lispが誕生したのです。\n
\n
Lispのすごさ\n
\n
　しばらく前になりますが、あるオブジェクト指向関連のイベントで「わたしがオブジェクト指向を理解したのは、Martin Fowlerの『リファクタリング』を読んでからです」という講演を聞いて驚愕しました。オブジェクト指向に最初に触れたのが1980年代で、処理系といえばSmalltalkというわたしのような人間は「もう、じじいの領域だな」と強く感じた一瞬でした。\n
　実際問題として、Javaではじめてオブジェクト指向を学んだ人はかなりの割合になっているようです。そういう人たちにとっては、オブジェクト指向が真新しい概念のように感じられるかもしれません。また、Javaで強調されている例外処理やガーベッジコレクション、バーチャルマシンなどの概念も、最近登場したもののように感じられることでしょう。\n
\n
　しかし、それらはみんなJavaより何十年も（文字どおり何十年も）前にLispで実現されていたのです。オブジェクト指向の登場が1968年のSimulaであったことをご存じの方も多いと思います。実に40年近くも前のことです。1980年代にはLisp処理系上にオブジェクト指向システムを構築する研究が多数行われており、それらの研究を踏まえて、1988年にはCommon Lispの標準としてCLOS（Common Lisp Object System）が取り込まれています。\n
　このCLOSは、多重継承やマルチプルメソッドなど現在でもまだ斬新と考えられる機能がたくさん盛り込まれています。また、最近話題のアスペクト指向に類似の機能*であるメソッドコンビネーションも含まれています。Javaなどがようやく取り込もうとしている技術は、20年前のLispの技術だったわけです。\n
　アスペクト指向だけではありません。Javaではじめてガーベッジコレクションを知った人も多いでしょうが、Lispはごく初期の処理系からガーベッジコレクションを備えていました。データをオブジェクトとして取り扱い、メモリの割り当てを明示的に行わないLispでは、ガーベッジコレクションは必須だったのです。これまた40年も前の技術ということになります。\n
　バーチャルマシン、バイトコードインタープリタなどの単語もJavaとともに広く知られるようになりましたが、もともとはSmalltalkで用いられていた技術です。Smalltalkの実装は1970年代後半から1980年代初頭にかけて行われており、その技術もまたLispの影響を受けています。見る人が見れば、Smalltalkの処理系はLispの処理系にそっくりであることが分かります。\n
　同じ時期に生まれたFORTRANやCOBOLが、いままで蓄積した膨大な資産を管理するために細々と生き残っているのに対して、Lispはいつも時代の最先端に位置しているのは興味深いことです。\n
\n
Lispの強さ\n
\n
　最先端の機能を提供してきたLispですが、その強さは特定の機能に見いだせるわけではありません。むしろ、いろいろな機能を実験してみるのに非常に便利なため、その中でよいものが生き残ったと考えるべきでしょう。Lispの先進性は、Lispの強さの副作用とでも呼ぶべきものなのです。\n
　その強さを表現するキーワードは「動的」です。インタープリタそのものであるevalを持っているLispは非常に動的で、単なるデータだけでなくプログラム自体を取り扱うことができます。Javaなどにもリフレクションという名前でプログラム自体を扱う機能が提供されていますが、データとプログラムが同一のフォーマットで表現されるLispの動的性にはかないません。プログラム自体を扱うプログラミング、メタプログラミングによって、Lispの上にいわば別の新しい言語を作り出すことが簡単にできます。新しく言語処理系を書かなくてもドメイン特化言語*を作り出すこともできますし、言語自体に手を加えなくてもオブジェクト指向機能のようなものも実現できます。\n
\n
Lispの不幸\n
\n
　そんなに優れた言語なのに広まらなかったLispは、不幸としか言いようがありません。もちろん、ただ単に運が悪かっただけではなく、いろいろと理由はあります。\n
　その1つはさまざまな誤解です。Lispはほかのプログラミング言語に比べて「高級」なので、実装が大変難しく、なかなか性能の良い処理系が登場しませんでした。性能第一のFORTRANなどの言語と比較すると、その点で長らく不利でした。その後、実装技術の向上によってほかの言語とそん色ない性能が出せるようになっても誤解は解けず、いつまでも「Lispは遅い、使えない」と思われてきたのです。また、学者しか使わない言語というイメージが形成されたのもつらいところです。\n
　もう1つの理由はあの括弧でしょう。Lispのプログラムには大量の括弧が登場します。慣れれば優先度などが明確に表現されるよい文法なのですが、少なくとも初心者は引いてしまいそうです。また、プログラミングスタイルが「普通」の言語とは相当異なることも問題です。この点では関数型言語も似たような障壁に当たっているようです。\n
\n
MatzLisp\n
\n
　JavaはLispで培われてきた技術を広く知らしめるのに貢献しました。いままで知る人ぞ知る技術であったものが、Javaのおかげで多くの人が知る「常識」に格上げされたといってもよいでしょう。しかしJavaには、Lispの強さのごく一部しか取り込まれていません。「時代は動的言語」といわれていますが、それはJavaが提供しなかったLispの強さを取り込んでいく、世間がますますLispの強さに気がついていく過程なのかもしれません。わたしのデザインしたRubyがその一翼を担っているのは誇らしい限りです。\n
　以前、某イベントの二次会で「実はRubyって『MatzLisp*』というLispの方言だったんだよ！」と語られたようです。何とも傑作なネタですが、Lispの強さを痛感したわたしが「自分が満足するために」作り出したRubyは、文法こそ違うものの、その本質としてLisp文化を継承しているのかもしれません。\n
	</item>
	<item>
20年間大きな変化のないプログラミング言語\n
\n
　以前、某雑誌のインタビューに答えているときに「プログラミング言語の領域では、ここ20年革新的な進歩は起こっていない」と発言して、記者の人を驚かせてしまいました。「これだけ進歩の激しいIT業界にあって、20年間にわたって革新的な進歩がないとはいったいどういうことか」という顔をしていました。\n
　前回でも紹介したように、プログラミング言語における革新的な「発明」はLispの周辺で登場してしまっています。進歩しているように見えるのは、最近になってようやく世間が追いついてきて、昔から存在していたものを「再発見」しているからです。オブジェクト指向に例外処理、ガーベッジコレクションやバーチャルマシンも何もかも、もう何十年も前から存在していたのです。知られていなかっただけで。\n
　もっともプログラミング言語というものは、もともと人間が自分の考えをどのように表現するかという「記法」としての性質が強いですから、人間の本質がなかなか変化しない以上、あまり急激には進歩できない領域ではあります。\n
　プログラミング以外の領域においても、決して進歩が速いとはいえそうにありません。急激に普及したネットワークの分野でも、あらためて考えてみれば、いまでも日常的に使われているメールが最初に発信されたのは30年以上前のことですし、インターネットの誕生からも同じくらい経過しています。Webは確かに目新しいアイデアですが、それを構成している技術的要素は古くから存在していたもので、決して革新的なものではありません。\n
　結局、普通の人が感じている「ITの目覚ましい発展」とは、実際には「ITの目覚ましい普及」にすぎなかったのでしょう。いままで知らなかったからといって、存在していなかったとは限りませんからね。\n
\n
ハードウェアの目覚ましい進歩\n
\n
　ソフトウェアの領域と比べて、ハードウェアの進歩には目覚ましいものがあります。\n
　1946年、世界最初の電子計算機と呼ばれたENIACは、1秒間に5000回の演算を行うことができたそうです。ということは、0.005MIPS*になりますね。さて、わたしの愛用するコンピュータでbogoMIPS*を計算すると3162bogoMIPSになるので、大雑把に比較すると63万2400倍になります。63万倍ですか……。技術の進歩は恐ろしいものですね。\n
　ところが、これらの変化が本当に「革新的」と呼べるものかというとよく分かりません。実際、世界で最も多く使われているCPUはいまだに30年以上前の命令アーキテクチャを引きずっているわけですし、逆に革新的だと思われたiAPX432*などのCPUアーキテクチャはほとんど失敗に終わっています。これらは連続的な進歩であって、別に革新的なことではないのかもしれません。小さな工夫を積み重ねてハードウェアの性能を向上させ、大量生産によって価格を低減し、高い計算能力を備えたデバイスを広く普及させてきた、不断の努力の結果だといえるでしょう。このような変化は連続的なものですが、偉大な変化でもあります。\n
　実際、63万倍の変化はばかにできません。同じx86アーキテクチャで比較しても、1978年リリースの8086/5MHz（0.33MIPS程度）と2004年リリースのPentium M/1.6GHz（3162MIPS程度）では、26年間にMIPS値が9500倍以上になっています。\n
\n
スケールによる劇的な変化\n
\n
　以上のことから、ITの変化というのは、ソフトウェアの進歩よりもハードウェアの性能向上と、価格低下による普及によって実現されてきたといっても過言ではないでしょう。これまでの歴史では考えられなかったような高性能のコンピュータが、広く、大量に使われるようになっているのです。連続的な変化とはいっても、これだけスケールが伴うと大きなインパクトが発生します。\n
　物理学の領域では、極端にスケールが違うとまったく異なる法則を使うことが知られています。例えば、極端に小さな素粒子の世界では、粒子はある場所に確率的にしか存在しないとか、どんなに観測精度を向上させても決して確定させることができない事象が存在するとか、日常的な常識では考えられないこと*が起こります。また、逆に何億光年という極端に大きなスケールにおいても、異なる法則が登場してきます。\n
　いま、この瞬間にITの世界でも似たようなことが発生しているような気がしてなりません。20年前、わたしたちがやり取りするメールの数は1日数通といったレベルでした。しかし、今や1日数百通のメールを受け取るのは普通のことで、中には数千通を受け取る人もいるでしょう。世界中に数千ページしかWebページが存在しなかったころと、数億ページの情報があふれている現在とでは、情報の探し方も異なってくるはずです。\n
　このような変化を発生させている元凶は、人間にあります。数百通のメール管理を想定して設計されたアプリケーションで数百万通のメールの管理を行うことは不可能ではないでしょうが、たぶんいろいろな局面で不都合が発生することでしょう。メールの処理に耐えがたい時間がかかったり、必要なメールを見つけ出すことができなかったり。あるいは、数億ページのWebからある単語を含むページを探し出すことは、通常のテキストファイルを検索するgrepのようなツールが用いているのと同じアルゴリズムを採用しても不可能ではないでしょうが、ベタに検索したのでは結果が出るまで何日もかかるでしょうし、検索結果として得られた単語を含んでいる数万ページのうち、どれが重要か判別することはほとんど不可能でしょう。人間には忍耐力にも取り扱うことのできる複雑さにも限界があるのです。\n
　このことをいち早く認識していたのがGoogleです。彼らは、ある情報を含むページをただ単にリスト化するだけでは不十分であり、どのページが重要であるかを高速かつ自動的に行う必要があることを認識していました。PageRankという手法を導入した彼らの検索エンジンは既存のライバルたちよりも「よい結果」を返し、Googleは後発ながらもあっという間に首位の座を獲得したのです。\n
\n
キーワードはスケーラビリティ\n
\n
　ということで、これからのキーワードは「スケーラビリティ」になると予想します。いままでと同じペースかどうかはともかく、コンピュータの性能はこれからも向上していくでしょう。また、ネットワークにつながれたコンピュータの台数や、それらの持つ記憶容量、また流通する情報量は、想像を超えるレベルで増加するはずです。「そのような事態にどう対処するか？」が今後の最も大きな課題になっていくわけです。\n
　考えてみれば、増大する複雑さに対処するというのは、プログラミング言語をはじめとしたソフトウェアが長年直面してきた課題ですが、これからはその増加速度がどんどん加速するのではないでしょうか。\n
　エクストリームプログラミング（XP）は、「テストがよいものであれば、限りなく頻繁に行えばよいだろう」「コードレビューがよいのであれば、いつもレビューしながらプログラムすればよいだろう」というように、ボリュームを極端（エクストリーム）にひねってみることから誕生したのだそうです。IT業界の未来を予想する際も、ボリュームを極限までひねってみるのがよいかもしれません。例えば、「インターネットユーザーが数十億人を超えたらどうなるだろう」とか「1日に受け取るメールが数万通を超えるようになったらどうしたらよいだろう」など。そのときは、できるだけ機械化／自動化する（Google PageRankの例）、みんなの力を結集する（Wiki、ソーシャルタギング*などの例）、非同期化してクライアントに処理を分散する（Ajaxなどの例）といった技法をいろいろと考案していく必要があります。ふと考えてみると、これらはみなWeb2.0*で注目されているものだったりします。Web2.0を説明するには、スケーラビリティの観点から行うとよいかもしれません。\n
　わたしの得意なプログラミング言語の領域でも、「ある言語から利用可能なライブラリが数万を超えたらどうなるだろう」とか「名前の衝突の回避や組織化をどう行えばよいのか」など、いろいろ考えることはありそうです。\n
	</item>
	<item>
プロジェクトの障害\n
\n
　2007年6月、15年ぶりにGPLの新版（v3）が公開されました。具体的な内容はともかく、フリーソフトウェア／オープンソースのライセンスが再び注目されています。今回はライセンスというものについて考えてみましょう。\n
　世の中にハッカー気質を持つ人はたくさんいますが、その数だけオープンソースプロジェクトが存在するかというと、なかなかそうはいきません。「自分でオープンソースプロジェクトを始める」のはハードルが高く、さまざまな障害があるわけですが、オープンソースプロジェクトにおける非技術的な障害の筆頭はライセンスでしょう。ほかの問題の多くは、そもそも根源的な問題である「何を作るのかを決める」とか、「実装手段を考える」あるいは「デバッグする」に至るまで、ある程度「ハッカー魂」を揺さぶるものがあります。だからこそ、ハッカーたちは喜んでプロジェクトに参加するわけです。\n
　ところが、ライセンスときたら、プログラムほど明確ではないし、技術的にも面白くもないし、その割りには厳密な話をし始めると面倒で、煮ても焼いてもおいしくありません。いっそ「こんなものなければよいのに」と思うほどです。では、なぜわざわざライセンスを用意するのかというと、主な理由は意思表明のためです。適切なライセンスには、「開発者がこのソフトウェアをどう扱ってほしいのか」という意思をはっきり示すことになります。それによって、ユーザーは安心してソフトウェアを使うことができるわけです。これが不明瞭な場合、ユーザーが確実に安心してソフトウェアを利用するには、開発者に対して直接問い合わせるしかありません。世界中から「こんなケースに使ってもよいか？」と問い合わせが殺到するのは、決してうれしいことではありません。また、ライセンスには、訴訟など法的なトラブルから守られる（かもしれない）という期待も込められています。\n
\n
ライセンスの選び方\n
\n
　オープンソースプロジェクトを開始するとして、そのソフトウェアに設定するライセンスとして何を選んだらよいでしょうか。\n
　わたしからできる最初のアドバイスは、「決して新しいライセンスを作らない」です。Rubyの開発を開始した時点でそのことが分かっていれば、わたしの人生はもうちょっとだけ楽だったでしょう。当時のわたしは、ソースコードの流用を明示的に許可したライセンスを提供したいと考えていました。そこで、Perlのライセンス（Artisticライセンス*）をベースに流用を許可し、入出力データ（Rubyの場合はRubyプログラム）には制限がおよばないことを明記したライセンスを用意しました。ライセンスを作るのは、プログラミングに少し似ています。何を許可したいとか、何を禁止したいとか考えるのはアルゴリズムのときと同じです。思い返せば、確かに作っていたときは楽しかったんです。\n
　しかし、この「コード」はプログラムよりもずっとデバッグが大変です。プログラムほど簡単に「実行」できないので、問題はすぐに発見されませんし、例え見つかっても簡単には修正できません。\n
　例えば、自分で作ったライセンスに含んだ条項に何らかの問題があったとしましょう。すぐに思いつくのは、GPLと互換性がなく、GPLソフトウェアとリンクできなくなってしまうケースです。「似たような思想に基づいて作られたライセンス同士が非互換とは、いったいどういうことか」と悲しくなりますが、これがライセンスの現実です。その場合には、（困るユーザーもいることでしょうが）GPLソフトウェアとのリンクをあきらめるか、あるいはライセンスの変更を行うことになります。\n
　このとき、ライセンスを適用するソフトウェアの全コードが1人によって書かれたものであれば、問題はほとんどありません。新しいバージョンを新しいライセンスでリリースすればそれでおしまいです。しかし、例えば別の人のパッチが含まれていれば、ソフトウェアはあなただけのものではなく、法的にはパッチを書いた人との共同著作物という扱いを受けます。厳密な話をすると、他人の権利を勝手に侵害するわけにはいきませんから、理論上ライセンスの変更にはこれら共同著作者すべての合意が必要です。何年もの間、開発を行ってきたRubyのようなソフトウェアでは、権利関係者が何人いるのかすでに確認しようがありません。FSF（Free Software Foundation）のソフトウェアのように、コードを貢献する場合には権利譲渡契約を結ぶようにしているなら楽なんでしょうが、パッチをもらうたびにそのような手続きを行うのも面倒です。たいていの場合は、ライセンスの変更をあきらめてしまうか、さんざん努力しても結局は全員の確認を取れず、誰かから苦情が出ないことを祈りつつ変更することになります。\n
　自分でライセンスを作る行為は、そのような苦労を何年にもわたって一手に引き受けることを意味するのです。心からアドバイスします。止めた方が無難です。\n
\n
オープンソースライセンスの選び方\n
\n
　あなたがオープンソースプロジェクトを開始するとして、将来問題が起きない（起きにくい）ライセンスを選ぶにはどうしたら良いでしょうか。\n
　世の中にはたくさんのオープンソースライセンス*が存在します。すでに多すぎるほどです。この中から選び出すだけで十分でしょう。それもメジャーなものを選択することをお勧めします。だいたいライセンス変更のようなトラブルが起きるのは、マイナーなライセンスを選んだプロジェクトと相場が決まっています。メジャーなものは広く使われているので、大きな問題が残っていないと考えられますし、いざというときに仲間が多いのも安心です。マイナーなライセンスでは、ほかのライセンスとの組み合わせなど十分な検討が行われていないことが多く、不安が残ります。\n
　ソフトウェアのライセンスを選ぶに当たって、まず考えなければならないのは「コピーレフトを望むかどうか」でしょう。コピーレフトとは、簡単に言うと「あなたの書いたフリーなソフトウェアに対して、自由を擁護しないものがタダ乗りすることを許さない」というものです。FSFはソフトウェアの自由の擁護者として、コピーレフトを強く推進しています。一方、コピーレフトについてそれほど気にしていない開発者も多いようです。あなたがコピーレフトを望むのであれば選択肢はほぼGPLしかありませんし、ライブラリとして使われるものであればLGPLも候補に挙がります。ライブラリにGPLを適用すると、事実上GPLソフトウェアからしか使えないので、より制限の緩いLGPLの方が広く使われる可能性があります。しかし、LGPLはあまり使い勝手が良くない上に、「分かりにくい」、「十分な考察が進んでいない」などの欠点がありますので、コピーレフトを強く望まない場合にはお勧めできません。\n
　コピーレフトにそれほどを強いこだわりのない人には、GPL以外の選択肢もあります。ここで重要なのは、「そのソフトウェアは、別のソフトウェアとのリンクが必要かどうか」です。将来、何らかの形でGPLソフトウェアとのリンクが予想される場合には、GPLとの互換性*が重要になります。プラグイン機能を持つソフトウェアやライブラリは、この点に注意しなくてはなりません。GPLと矛盾しないライセンスとしては、修正BSDライセンスやX11ライセンスなどがあります。\n
　もう1つの検討すべき要素は、関連ソフトウェアとライセンスをそろえることでしょう。例えば、EclipseプラグインなどはCPL（Common Public License）を選択すべきでしょう。また、PHP関連のソフトウェアは、PHPとライセンスをそろえた方が無難です。Rubyで書かれたソフトウェアは、Ruby自身とはライセンス的に独立なのですが、それでもRubyライセンスを選ぶ人が多いようです。避けたいライセンストラブル\n
　すでに述べたように、ライセンスのトラブルは「面倒くさい」、「面白くない」などイヤなものです。しかも、悪いことに法的な問題は「問題があるのかないのかはっきりしない」というオマケ付きです。「はっきりしたことは裁判してみないとね」といわれても、被告になんかなりたくないし……。\n
　訴訟リスクをゼロにすることは不可能みたいですが、それでも面倒な問題を回避するためにも、ライセンスについては賢くつきあいたいものです。そして、われわれの本来の「仕事」であるプログラミングに集中しましょう。Happy Hacking。\n
	</item>
	<item>
老化現象\n
\n
　時間とともに衰えていくのは世の常ですが、万年青年を目指すわたしも最近老化を感じるときがあります。最も端的なのは忘れっぽくなったことです。日常会話でも「アレ」とか「ソレ」とかを連発して、家族に笑われます。どうでもいいようなトリビアはいつまでも覚えているのに、日常生活にかかわる肝心なことを忘れてしまうのです。わたしの記憶はいったいどうなっているんでしょう。\n
　つい最近のことですが、海外出張の際、自宅を出てからパスポートを忘れているのに気がつき、慌てて取りに戻りました。さらに翌日、出張先のレストランでパスポートの入ったカバンを忘れるという失態を演じてしまいました。幸いすぐに気がついて、次の日には無事に回収できましたが、あまりの失敗にこれ以上ないほど落ち込みました。しかし、こんなうっかり者でも致命的な事態を回避できたのは、不幸中の幸いというか、悪運が強いというか。\n
　ハッカーたるもの、能力の不足はツールで補うべきでしょう。かくいうわたしも、幾つかのツールを使って役に立たない記憶力を補っています。\n
\n
スケジュール\n
\n
　まずはスケジュール管理。世のビジネスマンと比べるとアポイントメントの少なそうなわたしですが、それでもスケジュール管理は必要です。月に1度程度はどこかのイベントでプレゼンテーションを行っていますし、年に数回は海外出張もあります。また、仕事以外にも細々とした予定が入るものです。\n
　それらのスケジュール管理にはPDAを使っています。機種はもう骨董品レベルのVisor Edgeです。モノクロ低解像度で、最新機種に比べるとオモチャのようなものですが、意外と役に立って*くれています。\n
　一時は普段から持ち歩いているノートPCでスケジュール管理しようと思ったこともあったのですが、ノートPCではサスペンド状態から復帰するのにそれなりの時間（10秒程度）がかかります。通常の利用であればそれほど気にならない時間ですが、ちょっとスケジュールを確認するだけのときには耐えがたいほど長く感じます。フル充電のバッテリーでも3時間弱しか持たないので、残量をいつも気にしなければならない点も問題です。\n
　それに比べたら、PDAは起動が速いのでいざというときにすぐ見られますし、充電しなくても何日も持つのでバッテリー残量をほとんど気にする必要がありません。また、PDAではスケジュール管理しかしないので、CPUパワーも気にならないのです。ちなみにわたしは、日本語入力にPOBox*を、スケジュール一覧にDate@Glance*というソフトウェアを使っています。\n
\n
ToDo管理\n
\n
　PDAには、スケジュール管理以外にToDo管理やメモなどの機能がありますが、わたしはそれらをほとんど利用していません。ToDoなどを知りたいと思うときにはPCを起動していることが多く、わざわざPDAの打ちにくい入力方法*を使う必然性がないのです。\n
　ToDo管理をするソフトウェアはたくさんありますが、わたしは主にメールリーダーの機能を使っています。仕事の依頼の多くはメール経由でやってきますから、必要なメールに特定のラベルをつけておくことで、ToDoリストの代わりになります。自作のメールリーダー（morq）には、1キーでメールに「action」というラベルをつけたり、外したりする機能を用意しています。わたしの場合、スケジュールなどと独立したToDoはあまり存在しないので、この程度で十分のようです。PDAによるToDo管理は、入力が面倒なためにあまり更新しなくなり、更新しないのでチェックもせず、結局活用しなくなりました。また、Webアプリケーションを含む、そのほかのツールも長続きしませんでした。もっと忙しい人ならば、違った結論になるのかもしれません。\n
　また、現在のToDo管理方法に完全に満足しているわけでもないので、これからもToDo管理ツールについては考えていきたいと思っています。\n
\n
メモ\n
\n
　ちょっとした思いつきをその場限りで書きとどめるるためとか、考えをまとめるために書くメモは、その辺の紙切れに書きつけます。何でもPCに頼ってしまうのは悪い癖です。図やグラフを含めて考えを記述する方法としては、PCよりも古典的な手法である紙とペンの方が勝っています。\n
　しかし、紙が万能というわけではなく、幾つかの欠点もあります。1つは検索できない点です。紙に書かれたデータは後で検索できません。片づけ上手でないわたしは、書いたメモをすぐにどこかになくしてしまうので、後で参照する必要のあるデータは検索できる形式でPCに格納しておきます。\n
　もう1つの欠点は、書いた字を読めないことがある点です。わたしの字はお世辞にもほめられたものではありません。文章を書くのにPCを日常的に使うようになってからは、ペンで字を書く機会がすっかり減ってしまい、ますます汚い字になってしまいました。単に汚いだけなら恥ずかしいだけで済むのですが、後で自分でも読めないとなると笑えません。そのような欠点を考えると、文字だけで表現できるメモはやっぱりPCに入力するのが良さそうです。\n
　メモ入力に使っているツールは、Emacsでの「一人お手軽Wikiもどき」であるhowmです。実はhowmにはスケジュール管理機能とかToDo管理機能も付いているのですが、わたしはそれらをあまり活用していません。もっぱら「思いついたことを適当に書きとどめる」という使い方をしています。ふと浮かんだアイデアは、そのままだとすぐに忘れてしまうので、とりあえずhowmにメモとして放り込み（PCを起動していないときは紙に書いて後で入力）、必要に応じて後で検索しています。\n
　今回、自分のhowmメモの中身を振り返ってみると、「原稿のネタ」、「Ruby 2.0新仕様のアイデア（ボツになるもの多し）」、「日記*の下書き」、「議事録」などが多いようです。\n
　Webを眺めていて、日記のネタとして後でコメントしようと思った場合には、いしなおさんのMM/Memoを活用させてもらっています。Firefoxのbookmarkletで簡単に登録できるので重宝しています。興味を持ったページはとりあえずMM/Memoに登録しておき、後でその中から選んで日記に書いています。何でもWebブラウザで行う最近の風潮は（例えAjaxを駆使していても）あまり賛成できませんが、いま見ているものに対する処理をWebブラウザ内で行うことについては非常に合理的だと思います。\n
\n
協調作業\n
\n
　わたし自身の情報管理は前記の方法でほぼ満足しているのですが、これだけではカバーできないこともあります。それは複数の人がかかわる協調作業についてです。\n
　わたしのかかわる協調作業で最も重要なのは、やはりRubyの開発でしょう。特に、バグフィックスや機能拡張などにおけるToDo管理は必須です。このために利用しているツールは2つあり、1つは「Rubyのバグ（勝手に）トラッカー」です。これは、メーリングリストに報告されたバグがどんどん登録され、ChangeLogに対応するメール番号を入れてコミットすると、自動的にfixedマークがつけられます。\n
　バグの管理はRubyのバグ（勝手に）トラッカーで良いとしても、リリーススケジュールの管理には不十分です。Rubyの開発者は30人近くいますから、彼らをまとめるには別のツールが必要となります。この目的にはbasecampを使っています。これはRuby on Railsの開発者David Heinemeier Hanssonが所属する37signalsが提供しているプロジェクト管理ツールです。というか、basecampの基本部分を抜き出したものがRailsなのです。1.8.4リリースのときからbasecampを使い始めましたが、非常に便利です。\n
\n
いつでも最適化を\n
\n
　情報管理は基本中の基本です。ハッカーであれば、自分の情報管理を最適化するための工夫を怠ってはなりません。日々精進です。ところでこの原稿を書いていて、やり忘れていたToDoを発見してしまいました。わたしにもまだまだ改善の余地はありそうです。\n
	</item>
	<item>
先日、見ず知らずの方からメールをいただきました。プログラマーの後輩として、どのようにプログラミングを学べば良いか尋ねる内容です。以下、引用します。\n
\n
はじめまして。\n
僕は、今15歳です。\n
僕は、コンピュータにとても興味があり、近い将来、ITにかかわる仕事がしたく、まつもとさんのような超優秀なプログラマーになりたいと思っています。そこで、いまからITについて猛勉強しようと、いろんなWebサイトを見て回りましたが、何しろ情報量が非常に多く、かえって混乱してしまいました。そこで、ご質問なんですが、具体的にどのようなことから勉強を始めればいいですか。それから、入門に適切な書籍やWebサイトなども紹介していただければ幸いです。\n
お忙しいでしょうが、お返事をお待ちしております。\n
\n
　わたしごときが「超優秀なプログラマー」と呼ばれるのは気恥ずかしいのですが、若い人がプログラミングに対して真剣に向き合おうという姿勢はとても頼もしく感じました。\n
\n
昔の記憶\n
\n
　考えてみると、わたしの若いころと現在の若者とでは周囲の状況がまったく違います。わたしは、ちょうど彼と同じころにプログラミングを始めましたが、そのときに使っていたのはシャープのポケコン*で、400ステップのBASICプログラムを実行するのがやっとでした。\n
　あのころはインターネットというものはありませんから、情報の入手先も主に雑誌と書籍だけです。雑誌に載っているプログラムリストを必死に入力して、動かしては悦に入っていたことを覚えています。主にゲームでしたが、文字がピコピコ動く程度のかわいいものでした。\n
　それに比べると、いまの若い人たちは大変恵まれた環境にいます。世間にはコンピュータがあふれていますし、情報はインターネットからいくらでも入手できます。また、ゲームは昔に比べると超高速のマシン上で素晴らしい品質のものが遊べるようになりました。\n
　しかし、プログラミングに興味がある人は以前よりも減ってしまったようです。現代ではIT技術が進歩しすぎて、コンピュータを使うことと、プログラミングが分離してしまっているのかもしれません。\n
　傑作SF作品である『宇宙船ビーグル号の冒険*』の1エピソードでは、非常に優れた文明が、衛星も近くの惑星もないため、段階的に発展できず、恒星間航行の技術を発明することなく滅んでしまいます。コンピュータの発達期に少年であったわたしたちは、自分自身の成長に応じてコンピュータが発展してきました。しかし、いまの若者が「ファイナルファンタジー」を見て自分で作ろうと思っても、実現させるのはほとんど不可能*ではないでしょうか。\n
\n
先輩からの返事\n
\n
　現代において、コンピュータ好きのうち、プログラミングに興味を持つ人の割合は確かに下がっています。ただ、決していなくなったわけではありません。そして、その中にはインターネットからの情報とオープンソースの力を借りて、まさに超優秀なプログラマーが育っています。\n
　例えば、Haskell*を使ってPerl 6コンパイラの基礎を2週間で作ってしまったアンドレイ・タンは、そのとき20歳になったばかりでしたし、そのほかにも10代や20代前半で大きな成果を上げる若者もそれなりにいます。15歳でコンピュータとプログラミングに興味を持ち、優秀なプログラマーになりたいと考える彼も、将来大変有望なのではないでしょうか。\n
　そう思って、以下のような返事を書きました。\n
　お若いのにご自分の将来について真剣に考えていらっしゃることを大変うれしく思っています。\n
　さて、どのようなことから勉強を始めれば良いかという質問ですが、これは大変答えにくいものです。というのは、何が効果的かは人によって違うからです。同じ本を読んで感動する人もいれば、全然何も感じない人もいます。コンピュータの勉強も似たようなものだと思います。\n
　しかし、わたしがプログラミングを始めたのも15歳くらいでしたし、自分の若いころを振り返って役に立ちそうなことを幾つか挙げておきましょう。\n
　まず、コンピュータを使うこととプログラミングすることはまったく違うということをしっかり認識してください。昔、そう20年くらい昔にはこの2つはあまり区別されていませんでしたが、いまでは全然違います。ソフトウェアを使うのもまあ重要なことですが、プログラミングによってコンピュータに新しい仕事を教えこむことはそれ以上にエキサイティングで楽しいことです。\n
　次に、プログラミング言語について学んでください。それもできれば複数。プログラミングは言語を駆使して行います。言語を知らなければプログラミングはできません。そして、プログラムを作るのにどのプログラミング言語を使うかで、プログラマーの思考は影響を受けます。ですから、1つだけの言語では考え方が偏ってしまいます。C、C++、Javaのような言語と、RubyやPythonのような言語、それからLisp、ML*、Haskellのような言語の3種類からそれぞれ自分に向いていそうなものを学ぶといいと思います。\n
　プログラミングは手段であって目的ではないことに気をつけてください。つまり、プログラミングは（分かる人にとっては）とても楽しい行為ですが、それでも「完成したプログラムで何を実現するか」ということが最も重要なことで、それがなければプログラミングそのものにはたいして意味はなくなってしまいます。自分がどんな分野に興味があるのか、プログラムを作ることによってどんなことがしたいのか、そのことが分かれば能力を伸ばすことができると思います。\n
　わたしの知っている優秀なプログラマーは、みんな「自分が何を好きで、何がやりたいのか」をはっきり知っています。わたし自身はプログラミング言語にとても興味があり、いつか自分の言語を作ろうと心に思ったのは高校生のころでした。そのような気持ち（熱意）の継続により、大学に入り、就職し、Rubyを作り、世間から「優秀なプログラマー」と見なされるようになったわけです。自分から見れば、実際に優秀かどうかはやや疑問符がつきますが。いずれにしても、プログラミング言語を作りたいと思ってから実際にRubyを作るまでには10年以上かかっていますから、その間「作りたい」という気持ちを維持できたことが成功の1つの原因ではないかと思います。\n
　自分が何に興味があるのかある程度認識できたら、その分野を中心にほかの人の書いたプログラムを読むのが良いのではないかと思います。書籍に載っているサンプルプログラムや、オープンソースソフトウェアのソースコードなど読むことのできるプログラムはたくさんあります。ただ、漠然と読むのは難しいですし、興味を維持することができませんから、知りたいことを調べるために読むという目的意識が必要でしょう。\n
　わたしの若いころには思いどおりに使えるコンピュータなど個人レベルで買えるものではありませんから、中学生、高校生のころは本ばかり読んでいました。Pascalの本、Lispの本、人工知能の本など。ちゃんとプログラムを書き出したのは大学に入ってからです。それでも基本的な知識はあったので別に困りはしませんでした。\n
さて、年寄りの話はここまでです。パーソナルコンピュータが普及し、インターネットが当たり前になった時代に生きるいまの若い人は、また違った形でプログラミングを身につけるのではないかと思います。しかし、時代が変わっても、熱意とか継続とかは変わらない原則ではないかと思います。ご自分がなぜコンピュータに興味を持つようになって、本当はどんなことをしたいのか、ちょっと考えてみてはいかがでしょう。\n
\n
このような若者がいる限り、「未来は明るい」と信じたい今日このごろです。\n
	</item>
	<item>
マーケティング表裏\n
\n
　マーケティングはお金に魂を売った人たちのもの、それが言い過ぎなら、ビジネス指向の人たちだけのもの。そんなふうに考えていた時期がわたしにもありました。技術者は技術で勝負。技術的に優れたものを作ればそれで良い、と思っていたからです。しかし最近、少々考えをあらためつつあります。\n
　確かにマーケティングと呼ばれる活動の中には、ささいなことを大げさに表現したり、技術的にたいしたことのないものをさも素晴らしいことのように表現して、大衆の耳目を集めるのが目的となっているものもあります。エンジニアやハッカーのような中身が分かっている人々にとって、そのような活動はあまり尊敬できるものではありません。むしろ軽蔑（けいべつ）ややゆの対象となることが多いでしょう。\n
　しかし、すべてのマーケティング活動がそのような「邪悪なもの」というわけではありません。マーケティングには人間の心理的特性に着目し、好意的な反応を引き出すというような興味深い側面もあります。今回はそのようなマーケティングの側面と、オープンソースにおけるマーケティングについて考えてみましょう。\n
\n
オープンソースとマーケティング\n
\n
　オープンソースソフトウェア（以下OSS）は、その定義から無償で入手*できる必要があるので、市場の拡大・活性化を目的とするマーケティングとは無縁のようにも感じられます。OSSのユーザーが増えても、その増大に応じた「売り上げ」が上がるわけでもありませんし、ユーザーが増えたからといって開発者が増えるとも限りません。\n
　しかし、OSSの成功のためには、ある種のマーケティングが役に立つのではないかと最近感じ始めています。効果的なマーケティング手法を使うことによって、OSSプロジェクトの成功確率が高まるのではないかと思うようになったからです。\n
\n
オープンソースの成功\n
\n
　「OSSの定義」を満たすライセンスをつけてソースコードを公開したからといって、必ずしも成功するとは限りません。一昔前にしばしば見受けられた「OSSにすればコミュニティーができて、バザールモデル*が成立し、開発サイクルがうまく回る」などという幻想は、現実が知られるにつれて目にしなくなってきました。\n
　個人的な意見ですが、成功するためにまず必要なのは、何をもって成功とするかを定義することではないでしょうか。もちろん、偶然「成功」することもあるでしょうが、意図的に成功するには、どのような状態を達成できれば成功と見なすかを定めないと難しいはずです。\n
　では、ここで「OSSの成功」を定義しておきましょう。人によって定義は違うでしょうが、パッと考えつく範囲内では、\n
コミュニティーの成立\n
バザールモデルによる持続的な開発\n
好きなこと（OSS開発）をやりつつ生活の安定\n
などがあります。ほかにも、ビジネス的成功など、いろいろ考えられますが、取りあえず今回は前記のような成功に絞って考えましょう。\n
　これらの成功をまとめると、「持続」というキーワードが登場するような気がします。コミュニティーが成立しないようなプロジェクトは、オリジナルの開発者が延々と孤独に開発を続けることになりがちですし、開発者が飽きてしまえばそれでおしまいです。わたし自身の経験から考えても、外部からのインプットはモチベーションの維持に大変重要です。また、生活の安定も持続のために必要な要素で、学生主体のプロジェクトが主開発者の卒業や就職のために停止してしまった例*もたくさんあります。逆に、持続性が期待できないプロジェクトには参加をちゅうちょされるでしょうし、バザールモデルによる開発も成立しにくいでしょう。つまり、前記の定義に従えば、「OSSの成功とその持続性は、表裏一体である」ということができます。\n
\n
持続することの難しさ\n
\n
　「継続は力なり」という言葉もありますが、逆に「それだけ継続することは難しい」ということを意味しています。\n
　先日調査した結果*によると、Freshmeat.Netに登録されている25841プロジェクトのうち、実に61％に当たる15779プロジェクトが1年以上更新されていませんでした。「取りあえずアイデアを思いついて、プロジェクトを登録してみた」というPlanningレベルでは、実に8割を超えるプロジェクトが停滞しています。\n
　このデータは、持続的開発が実に困難であることを示しています。プロジェクトをOSSとして公開しても、必ずしもコミュニティーが成立するわけではなく、またそれだけで持続的に開発できるわけではないのです。\n
　では、持続的開発には何が必要なのでしょうか。重要なのは、開発者の生活の安定と外部からの継続的なインプットだと思います。しかし、これらは鶏と卵のようなものです。つまり、開発者の生活が安定するために仕事を頑張りすぎればOSSを開発する時間はなくなってしまいますし、逆にOSSを開発するために仕事を抑制すれば今度は生活が安定しません。一番良いのはOSS開発者としてどこかの企業に雇用され、OSS開発自体が仕事になることですが、そのためにはOSSそのものの価値が高く評価されることも必要でしょうし、OSS開発が安定している、つまりすでに持続的な開発が行われているかどうかが重視されそうです。持続的な開発のために生活の安定を求めているのに、そのためにはすでに持続的な開発が行われていることを求められるようでは、簡単な解決策はなさそうです。\n
では、いったいどうすれば良いのでしょう。\n
\n
持続への解決策\n
\n
　1つには開発者の生活の安定でしょう。OSS開発にかまけていても生活に不安がなければ、心配することなく開発に没頭できます。特に経済的な側面で心配のないことが重要です。しかし、親の遺産を受け継ぐような運の良い話はめったにありませんし、ビジネス的に成功してお金持ちになった人は、今度はビジネスに対する責任からOSS開発どころではない人の方が多そうです。結局、これはあまり一般的に有効な方法ではなさそうですね。\n
　もう1つの方法がマーケティングの利用です。商品ではないので「広報」と呼んだ方が良いのかもしれません。オープンソースは商品ではありませんから、売れなければならないというプレッシャーはありませんし、単純に考えればユーザーがどれほど増えても関係ないと思えます。しかし、ある程度以上のユーザーを獲得できれば、開発モチベーションの観点からも、コミュニティー形成の観点からも、大変有利です。また、LinuxやRubyのようにスポンサーによる支援*を受けるためには、そのプロジェクトが技術的に優れていることは当然として、「どれだけユーザーがいて、どれだけの影響力があるか」が重要になります。\n
\n
マーケティング手法\n
\n
　近年、OSS分野のマーケティングにおける成功例としては、Ruby on Rails*（以下Rails）が挙げられるでしょう。RailsはWebアプリケーションフレームワークとして優れている点はもちろんですが、「Javaの10倍の生産性」という分かりやすいキャッチフレーズや「わずか10分でブログソフトを実装」という人目を引くビデオによって注目されました。「分かる人だけ分かれば良い」というようなテキストオンリーの無愛想なドキュメントが横行するOSS業界にあって、このアプローチは特異だったように思えます。\n
　具体的には、\n
何が達成できるのか、分かりやすい表現\n
特にビジュアルな表現\n
が重要のようです。Rubyのような言語はこれが苦手なので、ずっと困っていました。言語はプログラムを書けば原理的には何でもできるからです。差別化も難しいですし。しかし、Railsの成功のおかげで「RubyではRailsが使えます」といえるようになりました。最近、Rubyが注目されている原因*の1つはRailsでしょう。ありがたいことです。\n
　これからはオープンソース分野においても、見栄えや広報などマーケティング的側面がますます重要視されるのかもしれません。\n
	</item>
	<item>
市場における5セクション\n
\n
　マーケティングに関する面白い話題としては、「キャズム」と呼ばれるものがあります。これは米国のマーケティングコンサルタントであるジェフリー・ムーア氏が提唱した概念です。\n
　彼によれば「市場は大きく分けて5つのセクションに分類できる」そうです。\n
イノベーター（新しモノ好き）\n
アーリーアダプター（差別化志向）\n
アーリーマジョリティ（差別化したいが危険は避ける）\n
レイトマジョリティ（定番志向）\n
ラガード（頑固者）\n
　新商品が出ると「人柱*」としてすぐに試してみるイノベーターや、取りあえず成功の見込みがありそうならやってみる*アーリーアダプターなどは、新しいものを受け入れるのに柔軟です。しかし、大衆はもっと保守的です。「失敗したら損」ですし、定着しなければ投資が無駄になることを恐れる気持ちと、新しい技術で差別化したい気持ちの両方を持つアーリーマジョリティは、成功例が複数登場するまで手を出しません。もっと保守的なレイトマジョリティは、周り全部がその技術に移行してしまって、重い腰を上げざるを得なくなるまで動きません。超守旧派であるラガードは、周りに取り残されても構わず古い技術に固執します。\n
　ある商品が次のセクションに受け入れられるのは大変です。特に、イノベーターとアーリーアダプターで構成される初期市場と、アーリーマジョリティやレイトマジョリティによって構成されるメジャー市場の間には、容易には越えられない「chasm（キャズム：深いミゾ）」があるとされています。新しい技術のマーケティングに関しては、「このセクション間のミゾをどう飛び越すか？」が課題になります。\n
　同じ人が、同時期に異なるセクションへ所属することもあります。例えば、わたしはプログラミング言語について、取りあえず新しいものを調べてみるという点ではアーリーアダプターレベルでしょうが、実際に使っているのはCとRubyばかりで、むしろレイトマジョリティレベルでしょう。エディタについては、いつまでたってもEmacsに固執するという点でラガードかもしれません。オープンソース関係者だからといって、いつもアーリーアダプターとは限らないわけです。\n
　キャズムはテクノロジーマーケティングの文脈で誕生した概念ですが、実際には人間が新しいものを受け入れる過程全般を表現していると思います。新しい文化、例えば日本のアニメが世界市場で受け入れられる過程を観察すると、似たような分類が見られることでしょう。\n
\n
キャズムの乗り越え方\n
\n
　では、キャズムを越えて、マジョリティ（大衆）にアピールするためにはどうしたらよいでしょう。大衆は周りの人が使っていないと使い始めないわけですし、周りの人が使っているということは、すでに大衆が受け入れているということになります。これでは「鶏と卵*」です。\n
　ジェフリー・ムーア氏は、「マーケットを小さなセグメントに分割して狭いマーケットでの成功事例を蓄積し、それを背景に近傍のセグメントへの波及効果を狙い、最終的に対象をマジョリティに拡大する」という方法を提案しています。分割統治のテクニックですね。\n
\n
オープンソースとキャズム\n
\n
　オープンソースソフトウェアの多くはボランティアによって開発されており、採算を気にする必要はありません。好きだから、楽しいから、という理由で開発に参加している有志には、採算やマーケットへのアピールなどあまり関係なさそうです。というか、本質的に無償であるオープンソースソフトウェアにマーケットって存在するんでしょうか。別にユーザーが少ないからといって、直ちに「不採算だから開発をやめる」ということにはならないわけですし。\n
　となると、マーケティングから誕生した概念であるキャズムは、オープンソースソフトウェアとは関係ないという結論になるのでしょうか？　そんなことはありません。前回も触れましたが、オープンソースソフトウェアにもある種のマーケティングが必要です。それは以下の理由によります。\n
\n
知名度の価値\n
コミュニティーの持続性\n
\n
　誰も知らないオープンソースソフトウェアは、開発者が1人、あるいは少数で細々と開発することになります。このようなソフトウェアは持続性という観点から脆弱です。「孤独な開発」は開発者のモチベーションを下げがちですし、不採算による開発の中止こそ存在しなくても、開発者が何らかの事情（卒業・就職、転職、家庭の事情、やる気がなくなった、など）で開発を続けられなくなると、そのプロジェクトは停止してしまいます。そして、停止したプロジェクトはほとんどの場合、再び顧みられることはなく、死に絶えてしまいます。\n
　逆に知名度があると、そのソフトウェアの周辺にはユーザーや開発者による「コミュニティー」が発生しやすくなります。実際にはコミュニティーができたからといって、すぐに開発協力者がどんどん出てくるわけではないのですが、たとえ開発に参加する人がそれほどいなくても、知名度とそれによるコミュニティーは大きな助けになります。ビジネスほどの大規模なマーケティングは不要としても、オープンソースにも知名度を高める必要があり、それは一種のマーケティングと呼んでも差し支えない活動です。そして、マーケティング活動には必ずキャズムがつきまとうのです。\n
　例えば、新しくオープンソースのDBMSが登場したとして、それが実際に広く使われるようになるまでに、高い壁があることは容易に想像できます。実績がないから使われず、使われないからなかなか実績が蓄積しない、というのは典型的なキャズムの構図です。\n
\n
オープンソースキャズムの深さ\n
\n
　さて、ここまでの観察をまとめると、\n
オープンソースにもマーケティングが必要\n
オープンソースにもキャズムがある\n
ことが分かります。人心に影響を与えるマーケティングに疎いわたしには残念な結論です。しかし、オープンソースのキャズム論には、通常のマーケットと違う要素が付け加わります。\n
　まず、アーリーアダプター層の大きさです。現時点では、オープンソースという概念そのものが、アーリーアダプターか、せいぜいアーリーマジョリティ層の手を出すレベルです。ようやくレイトマジョリティ層もオープンソースに気がついてきたくらいでしょうか。その結果、オープンソースに深くかかわっている人たちは、新しモノ好きの傾向が強いだろうといえるでしょう。\n
　次は、オープンソースの導入コストの低さです。オープンソースソフトウェアが無償といっても、新しいものを試すにはそれなりにコストが必要です。特に学習コストはバカになりません。しかし、商用ソフトウェアと比較すればコストは低いので、冒険しやすいことはいえるでしょう。\n
　最後に、開発を持続させるために必要な「顧客」が少なくて済む点があります。商品を販売することでコストを回収することを目指す「商品」とは異なり、オープンソースソフトウェアは開発持続に必要なモチベーションなどを維持することだけが必要です。これは、ビジネスを維持することに比べると圧倒的に少ない顧客数で達成できそうです。\n
　結果として、オープンソースキャズムは思ったよりも深くないということです。\n
\n
オープンソースキャズムの克服\n
\n
　では、どうすればよいのかといえば、やはりムーア氏の提唱した戦略を実践することでしょう。セグメントを限定して、そこでのシェアを高めることです。例えば、汎用言語であるRubyが、Ruby on RailsによってWebアプリケーションという分野で注目されたことは（わたしの意図したとおりというわけではありませんが）よい例です。また、「お試しコスト」を下げるため、既存のライバルとの互換性を高めて、移行しやすくするのも有効でしょう。\n
　キャズムを意識した戦略により、より多くのオープンソースソフトウェアが「生き残る」ようになればと祈っています。\n
	</item>
  </string-array>

</resources>